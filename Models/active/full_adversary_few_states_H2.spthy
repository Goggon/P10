theory handshake
begin

builtins: hashing, diffie-hellman, symmetric-encryption, asymmetric-encryption, signing, natural-numbers

functions: HKDFExpand/1, hmac/1, h1/1

macros: handshakeCryptoHeader() = </*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'>>,
        protocolVersion() = <'254', '253'>

/**** IMPORTANT  ****
  In DTLS 1.3, the message transcript is computed over the original TLS
  1.3-style Handshake messages without the message_seq,
  fragment_offset, and fragment_length values.  Note that this is a
  change from DTLS 1.2 where those values were included in the
  transcript.
********************/

// Adversary power
rule Reveal_DHExp:
  [ DHExp(~x, ~tid, $A) ] --[ RevDHExp(~x, ~tid, $A), Corrupt($A) ]-> [ Out(~x) ]

rule Reveal_LTK:
  [ !Ltk($A, ~ltk) ] --[ Corrupt($A) ]-> [ Out(~ltk) ]
/*
rule Drop:
  [ In(x) ] --> [  ]*/

// Asym key setup
rule Register_pk:
    [ Fr(~ltk) ]
  --[ Reg($A) ]->
    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]

// ClientHello
rule ClientHello:
  let
    ClientHello = 
      < /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ ~session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', 'g'^~a>
          >
        >
      >

    DTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ 1:nat,
        /*sequence_number*/ 1:nat,
        /*length*/ ~msg_len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <~msg_len, 1:nat, 1:nat, 1:nat>,
          ClientHello
        >
      >
  in
      [ Fr(~a),
        Fr(~session_id),
        Fr(~msg_len) ]
    --[ DH(~a, ~session_id, $C),
        Start($C, $S, 'client', ~session_id), /* We must make it a note that we are communicating with the server, so we can discard packages out of order*/ 
        Send($C, $S, 'CH', ~session_id),
        CH_ClientHello($C, $S, ~session_id, <'1', ClientHello>) ]->
      [ Out(<DTLSPlaintext, $C, $S>) /*clienthello plaintext*/,
        St_ClientHello(<$C, $S, ~a, ~session_id, <h1(<'1', ClientHello>)>>, <~session_id, 1:nat %+ 1:nat, 1:nat, 1:nat, 1:nat>), 
        DHExp(~a, ~session_id, $C) ]

// HelloRetryRequest
rule HelloRetryRequest:
  let
    /********** INCOMMING **********/
    ClientHello = 
      < 
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ client_session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', ga>
          >
        >
      >

    ClientDTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %epoch,
        /*sequence_number*/ %seq,
        /*length*/ len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <len, %seq, %off, %frag>,
          ClientHello
        >
      >
    /******************************/

    /********* HELLORETRYREQUEST ****************/
    HelloRetryRequest = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/        'HelloRetryRequest',
        /*CipherSuite*/     'CipherSuits',
        /*Extension*/ <
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <
              h1(<<'1', ClientHello>, 'HelloRetryRequest'>)
            >
          >
        >
      >

    DTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ 1:nat,
        /*sequence_number*/ 1:nat,
        /*length*/ ~msg_len,
        <
          /*Handshaketype*/   /*HandshakeType*/ '2', /*server_hello(2)*/
          <~msg_len, 1:nat, 1:nat, 1:nat>,
          HelloRetryRequest
        >
      >

    /*************************************/
  in
      [ Fr(~session_id),
        Fr(~msg_len),
        In(<ClientDTLSPlaintext, $C, $S>) /*clienthello plaintext*/ ]
    --[ Send($S, $C, 'HRR', ~session_id), Reach('HRR') ]->
      [ St_ServerHelloRetry(<$S, $C, ~session_id, h1(<<'1', ClientHello>, 'HelloRetryRequest'>), <h1(<'1', ClientHello>), <'2', HelloRetryRequest>>>, <~session_id, 1:nat %+ 1:nat, 1:nat, %seq %+ 1:nat, %epoch>, <<%epoch, %seq>>),
        Out(<DTLSPlaintext, $S, $C>) ]

// ClientHelloCookie
rule ClientHelloCookie:
  let
    /********* INCOMMING: HELLORETRYREQUEST ********/
    HelloRetryRequest = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/        'HelloRetryRequest',
        /*CipherSuite*/     'CipherSuits',
        /*Extension*/ <
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <
              cookie
            >
          >
        >
      >

    ServerDTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ len,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <len, %rec_seq, %off, %frag>,
          HelloRetryRequest
        >
      >

    /*************************************/

    /************* CLIENTHELLOCOOKIE ***********/
    ClientHelloCookie = 
      < 
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', 'g'^a>
          >,
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <cookie>
          >
        >
      >

    DTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %next_epoch,
        /*sequence_number*/ %next_seq,
        /*length*/ ~msg_len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>,
          ClientHelloCookie
        >
      >
    /*************************************/
  in
      [ Fr(~msg_len),
        In(<ServerDTLSPlaintext, $S, $C>),
        St_ClientHello(<$C, $S, a, session_id, <ClientHello>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>) ]
    --[ Instance(session_id, $C, 'client'),
        Send($C, $S, 'CHC', session_id), Reach('CHC') ]->
      [ St_ClientHelloCookie(<$C, $S, a, session_id, <ClientHello, <'2', HelloRetryRequest>, <'1', ClientHelloCookie>>>, <session_id, 1:nat, %next_epoch %+ 1:nat, %rec_seq %+ 1:nat, %rec_epoch>),
        Out(<DTLSPlaintext, $C, $S>) ]

// ServerHello
rule ServerHello:
  let
    /********** INCOMMING **********/
    ClientHelloCookie = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ client_session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', ga>
          >,
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <
              inc_cookie
            >
          >
        >
      >

    ClientDTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <len, %rec_seq, %off, %frag>,
          ClientHelloCookie
        >
      >
    
    // We must remove the cookie in order to compare the ClientHellos
    ClientHandshakeToCompare = 
      <
        /*HandshakeType*/ '1', /*client_hello(1)*/
        <
          /*ProtocolVersion*/ protocolVersion(), 
          /*Random32*/ client_session_id, 
          /*CipherSuite*/ 'CipherSuits', 
          /*Extension*/ <
            /*ExtensionType*/ '51', 
            /*KeyshareClientHello*/ <
              /*KeyshareEntry*/ <'g', ga>
            >
          >
        >
      >
    /******************************/

    traffic_key = ga^~b

    /********** SERVERHELLO **********/
    ServerHello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareServerHello*/ <'g', 'g'^~b>
        >
      >

    DTLSPlaintextSH = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %next_epoch,
        /*sequence_number*/ %next_seq,
        /*length*/ ~msg_len,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>,
          ServerHello
        >
      >
    /******************************/
  in
      [ St_ServerHelloRetry(<$S, $C, session_id, cookie, <ClientHello, HelloRetryRequest>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, <SHRecordNumbers>),
        In(<ClientDTLSPlaintext, $C, $S>) /*clienthello plaintext*/,
        Fr(~b),
        Fr(~msg_len) ]
    --[ DH(~b, session_id, $S), 
        Neq('g', ga), Neq(ga, traffic_key), Reach('SH'), /* Ensure gb is not DH_Neutral */
        DHChal($S, session_id, 'g', ~b, ga, 'g'^~b, ga^~b),
        Eq(inc_cookie, cookie), Eq(h1(<ClientHandshakeToCompare, 'HelloRetryRequest'>), cookie),
        Start($S, $C, 'server', session_id), /* We must make it a note that we are communicating with the client, so we can discard packages out of order*/ 
        Send($S, $C, 'SH', session_id),
        Nonce($S, <client_session_id, session_id>),
        SH_ClientHello($S, $C, session_id, ClientHandshakeToCompare) ]->
      [ Out(<DTLSPlaintextSH, $S, $C>) /*serverhello plaintext*/,
        !Keys(<$S, $C, session_id, 'g'^~b, ga, traffic_key>),
        St_ServerHello(<$S, $C, session_id, <ClientHello, HelloRetryRequest, <'1', ClientHelloCookie>, <'2', ServerHello>>>, <session_id, 1:nat, %next_epoch %+ 1:nat, 1:nat, %rec_epoch %+ 1:nat>, <SHRecordNumbers, <%rec_epoch, %rec_seq>>),
        DHExp(~b, session_id, $S),
        ServerNonce($S, <client_session_id, session_id>) ]

// EncryptedExtensions
rule EncryptedExtensions:
  let
    /********** ENCRYPTEDEXTENSION **********/
    EncryptedExtensions = 
    <
      /*Extension*/ <
          /*ExtensionType*/ '13', 
          /*EncryptedExtensions*/ 'encryptedExtensions'
      >
    >

    DTLSInnerPlaintextEE = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '8', /*encrypted_extensions(8)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>, 
          EncryptedExtensions
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextEE = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextEE
      >
    /******************************/
  in
      [ Fr(~msg_len),
        St_ServerHello(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'EE', session_id), Reach('EE') ]->
      [ Out(<DTLSCipherTextEE, $S, $C>) /*encryptedextensions encrypted*/,
        St_EncryptedExtensions(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, <'8', EncryptedExtensions>>>, <session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers, <$S, $C, session_id>) ]

// ServerCertificateRequest
rule ServerCertificateRequest:
  let
    CertificateRequest = 
      <
        /*certificate_request_context*/ //Empty length
        /*Extension*/ $client_alg
      >

    DTLSInnerPlaintextCR = 
      senc(<
        /*content*/ <
          /*HandshakeType*/ '13', /*certificate_request(13)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>,
          CertificateRequest
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >, traffic_key)

    DTLSCipherTextCR = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextCR
      >

  in
      [ Fr(~msg_len),
        St_EncryptedExtensions(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers, <$S, $C, session_id>),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        CertificateRequested('True') ]->
      [ CertificateRequested('True'),
        St_ServerCertificateRequest(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions>>, <session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers),
        Out(<DTLSCipherTextCR, $S, $C>) /* server request certificate */ ]

// ServerNoCertificateRequest
rule ServerNoCertificateRequest:
    [ St_EncryptedExtensions(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers, <$S, $C, session_id>) ]
  --[ CertificateRequested('False') ]->
    [ CertificateRequested('False'),
      St_ServerCertificateRequest(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions>>, <session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers) ]


// ServerCertificate
rule ServerCertificate:
  let
    /********** SERVERCERTIFICATE **********/
    %frag_max = 1:nat %+ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat
    ServerCertificate_1 = 
      <
        /*certificate_entry*/ 'ser'
      >

    DTLSInnerPlaintextSC_1 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_1, %next_seq, 1:nat, %frag_max>,
          ServerCertificate_1
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_1 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextSC_1
      >   

      ServerCertificate_2 = 
        <
          /*certificate_entry*/ 've'
        >

    DTLSInnerPlaintextSC_2 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_2, %next_seq, 1:nat %+ 1:nat, %frag_max>,  
          ServerCertificate_2
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_2 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextSC_2
      >   

    ServerCertificate_3 = 
      <
        /*certificate_entry*/ 'rC'
      >

    DTLSInnerPlaintextSC_3 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_3, %next_seq, 1:nat %+ 1:nat %+ 1:nat, %frag_max>, 
          ServerCertificate_3
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_3 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextSC_3
      >   

    ServerCertificate_4 = 
      <
        /*certificate_entry*/ 'er'
      >

    DTLSInnerPlaintextSC_4 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_4, %next_seq, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %frag_max>,  
          ServerCertificate_4
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_4 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextSC_4
      >  

    ServerCertificate_5 = 
      <
        /*certificate_entry*/ 't'
      >

    DTLSInnerPlaintextSC_5 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_5, %next_seq, %frag_max, %frag_max>,  
          ServerCertificate_5
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_5 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextSC_5
      >      

    // Reasembeled handshake record
    ServerCertificate = <ServerCertificate_1, ServerCertificate_2, ServerCertificate_3, ServerCertificate_4, ServerCertificate_5>
      
    /******************************/
  in
      [ Fr(msg_len_1),
        Fr(msg_len_2),
        Fr(msg_len_3),
        Fr(msg_len_4),
        Fr(msg_len_5),
        St_ServerCertificateRequest(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'C', session_id), Reach('SC') ]->
      [ Out(<DTLSCipherTextSC_1, $S, $C>), /*servercertificate encrypted fragment 1*/
        Out(<DTLSCipherTextSC_2, $S, $C>), /*servercertificate encrypted fragment 2*/
        Out(<DTLSCipherTextSC_3, $S, $C>), /*servercertificate encrypted fragment 3*/
        Out(<DTLSCipherTextSC_4, $S, $C>), /*servercertificate encrypted fragment 4*/
        Out(<DTLSCipherTextSC_5, $S, $C>), /*servercertificate encrypted fragment 5*/
        St_ServerCertificate(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>>>, <session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers) ]

// ServerCertificateVerify
rule ServerCertificateVerify:
  let
    /********** SERVERCERTIFICATEVERIFY **********/
    CertificateVerify = 
    <
      /*algorithm*/ $alg, 
      /*signature*/ sign(hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>>), ServerCertificate>), serverPrivateKey)
    >

    DTLSInnerPlaintextCV = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '15', /*certificate_verify(15)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>, 
          CertificateVerify
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ DTLSInnerPlaintextCV
      >
    /******************************/
  in
      [ Fr(~msg_len),
        !Ltk($S, serverPrivateKey),
        St_ServerCertificate(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'CV', session_id), Reach('SCV') ]->
      [ Out(<DTLSCipherTextCV, $S, $C>), /*servercertificateverify encrypted*/
        St_ServerCertificateVerify(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>, <'15', CertificateVerify>>>, <session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers) ]

// ServerFinished
rule ServerFinished:
  let
    /********** SERVERFINISHED **********/
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    ServerFinished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>)>)
      >

    DTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <~msg_len, %next_seq, 1:nat, 1:nat>, 
            ServerFinished
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /******************************/
  in
      [ Fr(~msg_len),
        St_ServerCertificateVerify(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, RecordNumbers),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>),
        ServerNonce($S, <client_session_id, session_id>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'SF', session_id), Reach('SF'),
        Running($S, 'server', session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>, traffic_key) /* Used to ensure peer authentication, if a client has accepted a servers indentity, then a server must have sent their identity on a session equal to the one sent by the client*/ ]->
      [ Out(<DTLSCipherTextSF, $S, $C>), /*server finished*/
        ServerFinished(<$S, $C, finished_key>, <$S, $C, hmac(<finished_key, h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>)>), <client_session_id, session_id>>),
        St_ServerFinished(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, <'20', ServerFinished>>>, <session_id, %next_seq %+ 1:nat, %next_epoch %+ 1:nat, %rec_seq, %rec_epoch>, RecordNumbers) ]


//ClientFinished
rule ClientFinishedNoAuth:
  let
    traffic_key = gb^a

    /********** INCOMMING: SERVERHELLO **********/
    ServerHello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ server_session_id,  
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
            /*ExtensionType*/ '51', 
            /*KeyshareServerHello*/ <'g', gb>
        >
      >

    DTLSPlaintextSH = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ lenSH,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <lenSH, %rec_seq, %offSH, %fragSH>,
          ServerHello
        >
      >
    /********************************************/

    /********** INCOMMING: ENCRYPTEDEXTENSION **********/
    EncryptedExtensions = 
      <
        /*Extension*/ <
            /*ExtensionType*/ '13', 
            /*EncryptedExtensions*/ 'encryptedExtensions'
        >
      >

    DTLSCipherTextEE = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '8', /*encrypted_extensions(8)*/
            <lenEE, 1:nat, %offEE, %fragEE>, 
            EncryptedExtensions
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >

    /********************************************/

    /********** INCOMMING: SERVERCERTIFICATE **********/
    DTLSCipherTextSC_1 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_1, 1:nat %+ 1:nat, %offSC_1, %fragSC_1>,
            ServerCertificate_1
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_2 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_2, 1:nat %+ 1:nat, %offSC_2, %fragSC_2>,
            ServerCertificate_2
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_3 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_3, 1:nat %+ 1:nat, %offSC_3, %fragSC_3>,  
            ServerCertificate_3
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_4 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_4, 1:nat %+ 1:nat, %offSC_4, %fragSC_4>,  
            ServerCertificate_4
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >  

    DTLSCipherTextSC_5 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_5, 1:nat %+ 1:nat, %offSC_5, %fragSC_5>,  
            ServerCertificate_5
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >    

    // Reasembeled
    ServerCertificate = <ServerCertificate_1, ServerCertificate_2, ServerCertificate_3, ServerCertificate_4, ServerCertificate_5>
      
                  
    /******************************/

    /********** INCOMMING: SERVERCERTIFICATEVERIFY **********/
    CertificateVerify = 
    <
      /*algorithm*/ $alg, 
      /*signature*/ serverSignature //hmac(<h1(<DTLSHandshake_CH, DTLSSH, DTLSEE, DTLSSC>), 'serverCert'>) 
    >

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <lenSCV, 1:nat %+ 1:nat %+ 1:nat, %offSCV, %fragSCV>, 
            CertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: SERVERFINISHED **********/
    ServerFinished = 
      <
        /*verify_data*/ server_finished
      >
      
    ServerDTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <lenSF, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %offSF, %fragSF>, 
            ServerFinished
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /********************************************/

    /********** CLIENTFINISHED **********/
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    ClientFinished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>>)>)
      >

    DTLSCipherText =  
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <~msg_len, %next_seq, 1:nat, 1:nat>, 
            ClientFinished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /**********************************/
  in
      [ Fr(~msg_len),
        St_ClientHelloCookie(<$C, $S, a, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>),
        !Pk($S, serverPublicKey),
        In(<DTLSPlaintextSH, $S, $C>) /*serverhello plaintext*/,
        In(<DTLSCipherTextEE, $S, $C>) /*encryptedextensions encrypted*/,
        In(<DTLSCipherTextSC_1, $S, $C>), /*servercertificate encrypted fragment 1*/
        In(<DTLSCipherTextSC_2, $S, $C>), /*servercertificate encrypted fragment 2*/
        In(<DTLSCipherTextSC_3, $S, $C>), /*servercertificate encrypted fragment 3*/
        In(<DTLSCipherTextSC_4, $S, $C>), /*servercertificate encrypted fragment 4*/
        In(<DTLSCipherTextSC_5, $S, $C>), /*servercertificate encrypted fragment 5*/
        In(<DTLSCipherTextCV, $S, $C>), /*servercertificateverify encrypted*/
        In(<ServerDTLSCipherTextSF, $S, $C>) /*server finished*/ ]
    --[ Instance(session_id, $C, 'client'),
        HandshakeComplete($C, $S, 'client', traffic_key, <session_id, server_session_id>), Reach('CFNoAuth'),
        DHChal($C, session_id, 'g', a, 'g'^a, gb, gb^a),
        SessionKey($C, $S, 'client', session_id, traffic_key, 'auth'),
        FragmentsInOrder(%offSC_1, %offSC_2, %offSC_3, %offSC_4, %offSC_5),
        Nonce($C, <session_id, server_session_id>),
        CommitAuth($C, $S, 'client', session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>>, traffic_key), /* Used to ensure peer authentication, if a client has accepted a servers indentity, then a server must have sent their identity on a session equal to the one sent by the client*/
        Neq('g', gb), Neq(gb, traffic_key), /* Ensure gb is not DH_Neutral */
        Eq(hmac(<finished_key, h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>>)>), server_finished), 
        Eq(verify(serverSignature, hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>>), ServerCertificate>), serverPublicKey), true),
        Send($C, $S, 'CF', session_id) ]->
      [ Out(<DTLSCipherText, $C, $S>) /*client finished*/ ]

//ClientFinished
rule ClientFinishedAuth:
  let
    traffic_key = gb^a

    /********** INCOMMING: SERVERHELLO **********/
    ServerHello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ server_session_id,  
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
            /*ExtensionType*/ '51', 
            /*KeyshareServerHello*/ <'g', gb>
        >
      >

    DTLSPlaintextSH = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ lenSH,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <lenSH, %rec_seq, %offSH, %fragSH>,
          ServerHello
        >
      >
    /********************************************/

    /********** INCOMMING: ENCRYPTEDEXTENSION **********/
    EncryptedExtensions = 
      <
        /*Extension*/ <
            /*ExtensionType*/ '13', 
            /*EncryptedExtensions*/ 'encryptedExtensions'
        >
      >

    DTLSCipherTextEE = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '8', /*encrypted_extensions(8)*/
            <lenEE, 1:nat, %offEE, %fragEE>, 
            EncryptedExtensions
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >

    /********************************************/

    /********** INCOMMING ***********/
    CertificateRequest = 
      <
        /*certificate_request_context*/ //Empty length
        /*Extension*/ $client_alg
      >

    DTLSCipherTextCR = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '13', /*certificate_request(13)*/
            <lenCR, 1:nat %+ 1:nat, %offCR, %fragCR>,
            CertificateRequest
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /******************************/

    /********** INCOMMING: SERVERCERTIFICATE **********/
    DTLSCipherTextSC_1 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_1, 1:nat %+ 1:nat %+ 1:nat, %offSC_1, %fragSC_1>,
            ServerCertificate_1
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_2 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_2, 1:nat %+ 1:nat %+ 1:nat, %offSC_2, %fragSC_2>,
            ServerCertificate_2
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_3 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_3, 1:nat %+ 1:nat %+ 1:nat, %offSC_3, %fragSC_3>,  
            ServerCertificate_3
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_4 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_4, 1:nat %+ 1:nat %+ 1:nat, %offSC_4, %fragSC_4>,  
            ServerCertificate_4
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >  

    DTLSCipherTextSC_5 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_5, 1:nat %+ 1:nat %+ 1:nat, %offSC_5, %fragSC_5>,  
            ServerCertificate_5
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >    

    // Reasembeled
    ServerCertificate = <ServerCertificate_1, ServerCertificate_2, ServerCertificate_3, ServerCertificate_4, ServerCertificate_5>            
    /******************************/

    /********** INCOMMING: SERVERCERTIFICATEVERIFY **********/
    ServerCertificateVerify = 
      <
        /*algorithm*/ $alg, 
        /*signature*/ serverSignature //hmac(<h1(<DTLSHandshake_CH, DTLSSH, DTLSEE, DTLSSC>), 'serverCert'>) 
      >

    DTLSCipherTextSCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <lenSCV, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %offSCV, %fragSCV>, 
            ServerCertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: SERVERFINISHED **********/
    ServerFinished = 
      <
        /*verify_data*/ server_finished
      >
      
    ServerDTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <lenSF, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %offSF, %fragSF>, 
            ServerFinished
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /********************************************/

    /********** CERTIFICATE **********/
    ClientCertificate = 
      <
        /*certificate_entry*/ 'clientCert'
      >

    DTLSCipherTextCC = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <~msg_len_1, %next_seq, 1:nat, 1:nat>,  
            ClientCertificate
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** CERTIFICATEVERIFY **********/
    CertificateVerify = 
      <
        /*algorithm*/ $client_alg, 
        /*signature*/ sign(hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>, <'20', ServerFinished>>), 'clientCert'>), clientPrivateKey)
      >

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <~msg_len_2, %next_seq %+ 1:nat, 1:nat, 1:nat>, 
            CertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** CLIENTFINISHED **********/
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    ClientFinished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>>)>)
      >

    DTLSCipherText =  
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <~msg_len, %next_seq %+ 1:nat %+ 1:nat, 1:nat, 1:nat>, 
            ClientFinished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /**********************************/
  in
      [ Fr(~msg_len), Fr(~msg_len_1), Fr(~msg_len_2),
        St_ClientHelloCookie(<$C, $S, a, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>),
        !Pk($S, serverPublicKey),
        In(<DTLSPlaintextSH, $S, $C>), /*serverhello plaintext*/
        In(<DTLSCipherTextEE, $S, $C>), /*encryptedextensions encrypted*/
        In(<DTLSCipherTextSC_1, $S, $C>), /*servercertificate encrypted fragment 1*/
        In(<DTLSCipherTextSC_2, $S, $C>), /*servercertificate encrypted fragment 2*/
        In(<DTLSCipherTextSC_3, $S, $C>), /*servercertificate encrypted fragment 3*/
        In(<DTLSCipherTextSC_4, $S, $C>), /*servercertificate encrypted fragment 4*/
        In(<DTLSCipherTextSC_5, $S, $C>), /*servercertificate encrypted fragment 5*/
        In(<DTLSCipherTextSCV, $S, $C>), /*servercertificateverify encrypted*/
        In(<ServerDTLSCipherTextSF, $S, $C>), /*server finished*/
        In(<DTLSCipherTextCR, $S, $C>),
        !Ltk($C, clientPrivateKey) ]
    --[ Instance(session_id, $C, 'client'),
        HandshakeComplete($C, $S, 'client', traffic_key, <session_id, server_session_id>), Reach('CFAuth'),
        DHChal($C, session_id, 'g', a, 'g'^a, gb, gb^a),
        SessionKey($C, $S, 'client', session_id, traffic_key, 'auth'),
        FragmentsInOrder(%offSC_1, %offSC_2, %offSC_3, %offSC_4, %offSC_5),
        Nonce($C, <session_id, server_session_id>),
        Running($C, 'client', session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>, <'20', ServerFinished>>, traffic_key),
        CommitAuth($C, $S, 'client', session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>>, traffic_key), /* Used to ensure peer authentication, if a client has accepted a servers indentity, then a server must have sent their identity on a session equal to the one sent by the client*/
        Neq('g', gb), Neq(gb, traffic_key), /* Ensure gb is not DH_Neutral */
        Eq(hmac(<finished_key, h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>>)>), server_finished), 
        Eq(verify(serverSignature, hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>>), ServerCertificate>), serverPublicKey), true),
        ClientCert($C, $S, session_id, ClientCertificate),
        Send($C, $S, 'CF', session_id) ]->
      [ Out(<DTLSCipherText, $C, $S>) /*client finished*/,
        Out(<DTLSCipherTextCC, $C, $S>), 
        Out(<DTLSCipherTextCV, $C, $S>) ]

// Ack
rule Ack:
  let
    /********** INCOMMING: CERTIFICATE **********/
    ClientCertificate = 
      <
        /*certificate_entry*/ 'clientCert'
      >
    
    DTLSCipherTextCC = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %rec_seq,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenCC, %rec_seq, %offCC, %fragCC>,  
            ClientCertificate
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: CERTIFICATEVERIFY **********/
    ClientCertificateVerify = 
      <
        /*algorithm*/ $client_alg, 
        /*signature*/ clientSignature
      >

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %rec_seq %+ 1:nat,
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <lenCV, %rec_seq %+ 1:nat, %offCV, %fragCV>, 
            ClientCertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: FINISHED **********/
    DTLSCipherTextCF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %rec_seq %+ 1:nat %+ 1:nat,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <lenCF, %rec_seq %+ 1:nat %+ 1:nat, %offCF, %fragCF>, 
            client_finished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /******************************/

    /********** ACK ***************/
    DTLSCipherTextACK = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ senc(<
          /*content*/ <CHRecordNumbers, CHCRecrodNumbers, <1:nat %+ 1:nat %+ 1:nat, %rec_seq>, <1:nat %+ 1:nat %+ 1:nat, %rec_seq %+ 1:nat>, <1:nat %+ 1:nat %+ 1:nat, %rec_seq %+ 1:nat %+ 1:nat>>, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '26'
        >, traffic_key)
      >
    /*********************/
  in
      [ In(<DTLSCipherTextCC, $C, $S>),
        In(<DTLSCipherTextCV, $C, $S>),
        In(<DTLSCipherTextCF, $C, $S>),
        !Pk($C, clientPublicKey),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>),
        St_ServerFinished(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, <CHRecordNumbers, CHCRecrodNumbers>),
        ServerFinished(<$S, $C, finished_key>, <$S, $C, server_finished, nonce>),
        CertificateRequested(auth_status) ]
    --[ Instance(session_id, $S, 'server'),
        Eq(client_finished, server_finished), 
        Eq(auth_status, 'True'), Reach('ACK'),
        Eq(verify(clientSignature, hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>), 'clientCert'>), clientPublicKey), true),
        CommitAuth($S, $C, 'server', session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>, traffic_key),
        HandshakeComplete($S, $C, 'server', traffic_key, nonce),
        SessionKey($S, $C, 'server', session_id, traffic_key, 'auth'),
        Send($S, $C, 'ACK', session_id) ]->
        [ Out(DTLSCipherTextACK),
          Out(traffic_key)]
      
// AckNoAuth
rule AckNoAuth:
  let
    /****** INCOMMING: CLIENTFINISH ******/
    DTLSCipherText = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %rec_seq,
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <len, %rec_seq, %off, %frag>, 
            client_finished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /************************************/

    /********** ACK ***************/
    DTLSCipherTextACK = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*sequence_number*/ %next_seq,
        /*encrypted_record*/ senc(<
          /*content*/ <CHRecordNumbers, CHCRecrodNumbers, <1:nat %+ 1:nat %+ 1:nat, %rec_seq>>, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '26'
        >, traffic_key)
      >
    /*********************/
  in
      [ In(<DTLSCipherText, $C, $S>),
        St_ServerFinished(<$S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>>, <session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch>, <CHRecordNumbers, CHCRecrodNumbers>),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>),
        ServerFinished(<$S, $C, finished_key>, <$S, $C, server_finished, nonce>),
        CertificateRequested(auth_status) ]
    --[ Instance(session_id, $S, 'server'),
        Eq(client_finished, server_finished), Eq(auth_status, 'False'), Reach('ACKNoAuth'),
        HandshakeComplete($S, $C, 'server', traffic_key, nonce),
        SessionKey($S, $C, 'server', session_id, traffic_key, 'not_auth'),
        Send($S, $C, 'ACK', session_id) ]->
      [ Out(DTLSCipherTextACK) ]


// Restriction to allow for equality checks
restriction Equal:
"
  All x y #i.
    Eq(x, y) @ #i ==> x = y
"

// Restriction made to allow for inequality checks
restriction Not_equal:
"
  All x y #i.
    Neq(x, y) @ #i ==> not(x = y)
"

// Restriction only allow each actor to register one longterm-key
restriction Only_one_ltk_per_actor:
"
All A #i #j.
Reg(A) @ i & Reg(A) @ j ==> #i = #j
"

lemma V1_Reachability_with_both_actors[use_induction]:
exists-trace
"Ex C S client_session_id server_session_id traffic_key #i #j #k #l. 
Start(C, S, 'client', client_session_id) @ i & Start(S, C, 'server', server_session_id) @ j
& HandshakeComplete(C, S, 'client', traffic_key, <client_session_id, server_session_id>) @ k & HandshakeComplete(S, C, 'server', traffic_key, <client_session_id, server_session_id>) @ l
& not(Ex #p. Corrupt(C) @ p) 
& not(Ex #q. Corrupt(S) @ q)
& not(Ex #r. K(traffic_key) @ r)
"

lemma adv_know_key:
  "Ex actor1 actor2 session_id HandshakeHistory key #i #j.
    Running(actor1, actor2, session_id, HandshakeHistory, key)@i &
    K(key)@j"

/************** REUSE LEMMA ********************/
lemma R6_only_one_start_per_tid[reuse]:
"
  All session_id actor1 actor2 peer1 peer2 role1 role2 #i #j.
    Start(actor1, peer1, role1, session_id) @ i & Start(actor2, peer2, role2, session_id) @ j 
      ==> #i = #j
"

lemma R8_one_dh_per_x[reuse]:
"
  All tid tid2 x actor actor2 #i #j.
    DH(x, tid, actor) @ i & DH(x, tid2, actor2) @ j ==> #i = #j
"

lemma R7_dh_invariant[reuse]:
"
  All tid actor x #i. RevDHExp(x, tid, actor)@i ==>
    Ex #j. DH(x, tid, actor)@j & #j < #i 
"

lemma R5_Session_id_invariant[reuse]:
"
  All session_id actor role #i.
    Instance(session_id, actor, role) @ i
      ==> (Ex peer #j. Start(actor, peer, role, session_id) @ j & (#j < #i))
      
"

/*lemma dh_challenge[reuse]:
"
  All actor1 actor2 random1 random2 g a b ga gb gab #i #j #r.
    DHChal(actor1, random1, g, a, ga, gb, gab) @ i 
    & DHChal(actor2, random2, g, b, ga, gb, gab) @ j
    & not(#i = #j)
    & K(gab) @ r
      ==> 
        (Ex #p. RevDHExp(a, random1, actor1) @ p) | 
        (Ex #q. RevDHExp(b, random2, actor2) @ q) |
        (Ex #s. Corrupt(actor1) @ s) | 
        (Ex #t. Corrupt(actor2) @ t) 
"*/


lemma consistent_nonces[reuse]:
  "All actor1 actor2 role session_id HandshakeHistory key #i. 
    CommitAuth(actor1, actor2, role, session_id, HandshakeHistory, key)@i ==>
      Ex #j. Running(actor1, role, session_id, HandshakeHistory, key)@j"

lemma matching_sessions[reuse]:
  "All actor1 actor2 role1 role2 session_id1 session_id2 HandshakeHistory key #i #j #k.
    Running(actor1, role1, session_id1, HandshakeHistory, key)@i & 
    Running(actor2, role2, session_id2, HandshakeHistory, key)@j &
    not (role1 = role2) &
    K(key)@k ==>
      (Ex random1 a #r. RevDHExp(a, random1, actor1) @ r & #r < #i) |
      (Ex random2 b #r. RevDHExp(b, random2, actor2) @ r & #r < #j) |
      (Ex #r. Corrupt(actor1) @ r & #r < #i) | 
      (Ex #r. Corrupt(actor2) @ r & #r < #j)"

/****** DEBUG ******/

// Debug restriction to only have one client active in the system
// The adversary can act as other client from the active clients point of view
restriction DEBUG_Only_one_session_client:
"
  All a1 a2 a3 a4 sid1 sid2 #i #j. 
    Start(a1, a2, 'client', sid1) @ i & Start(a3, a4, 'client', sid2) @ j ==> #i = #j
"

/*restriction DEBUG_At_most_two_clients:
"
  All a1 a2 a3 a4 a5 a6 sid1 sid2 sid3 #i #j #k. 
    Start(a1, a2, 'client', sid1) @ i & 
    Start(a3, a4, 'client', sid2) @ j &
    Start(a5, a6, 'client', sid3) @ k 
    ==> (#i = #j) | (#i = #k) | (#j = #k)
"*/

// Debug restriction to only have one server active in the system
// This is less likely to be realistic, and should not be activeated in the general scheme of things
restriction DEBUG_Only_one_session_server:
"
  All a1 a2 a3 a4 sid1 sid2 #i #j. 
    Start(a1, a2, 'server', sid1) @ i & Start(a3, a4, 'server', sid2) @ j ==> #i = #j
"

/*restriction DEBUG_At_most_two_servers:
"
  All a1 a2 a3 a4 a5 a6 sid1 sid2 sid3 #i #j #k.
    Start(a1, a2, 'server', sid1) @ i &
    Start(a3, a4, 'server', sid2) @ j &
    Start(a5, a6, 'server', sid3) @ k
    ==> (#i = #j) | (#i = #k) | (#j = #k)
"*/

// Restriction R1: Restrict the actors to not instigate in more than one handshake with each others at a time
// This is relistic, since two honest actors to not want to attempt to instantiate two handshakes with each other at one time
// The restriction specify; If two session has been started, then the first session must have been complete before the new one start
restriction R1_Only_one_session_per_pair_at_a_time:
"
  All actor1 actor2 role session_id1 session_id2 #i #j.
    Start(actor1, actor2, role, session_id1) @ i & Start(actor1, actor2, role, session_id2) @ j & i < j
      ==> Ex traffic_key #k. HandshakeComplete(actor1, actor2, role, traffic_key, <session_id1, session_id2>) @ k & k < j & i < k
"

// Restriction R2: Restrict the actors to not make sessions with them selves
// The restriction is self explanitory
// The restriction specify; Actors may not start a session with them self
restriction R2_Dont_essablish_session_with_self:
"
  All actor1 actor2 role session_id #i.
    Start(actor1, actor2, role, session_id) @ #i & actor1 = actor2 ==> F
"

// Restriction R3: Dont resend messages. If a message that has already been processed is received again, ignore it.
// The restriction is a measure taken directly from the specification to not allow for replay attacks
// The restriction specify; If a message type is send twich on the same session id, then it must happen at the same time (it has in fact only been send once)
restriction R3_Dont_resend_messages:
"
  All actor1 actor2 msg_type session_id #i #j.
    Send(actor1, actor2, msg_type, session_id) @ #i & Send(actor1, actor2, msg_type, session_id) @ #j ==> #i = #j
"

// Restriction R4: Fragment offsets must be in the correct order. 
// All traces should only process messages in the correct order accoding to offset. In the model offset is defined as natural numbers starting 
// from the number 1.
// The restriction specify; If fragments are received, they should be in the order frag_offset_1 is the lowest and frag_offset_5 is the highest
restriction R4_Fragments_in_order:
"
  All %frag_offset_1 %frag_offset_2 %frag_offset_3 %frag_offset_4 %frag_offset_5 #i.
    FragmentsInOrder(%frag_offset_1, %frag_offset_2, %frag_offset_3, %frag_offset_4, %frag_offset_5) @ i
      ==> %frag_offset_1 ⊏ %frag_offset_2 & %frag_offset_2 ⊏ %frag_offset_3 & %frag_offset_3 ⊏ %frag_offset_4 & %frag_offset_4 ⊏ %frag_offset_5
"

restriction R9_rev_dh_before_hs:
"
  All tid actor role hs session_id key x #i #j.
    Running(actor, role, session_id, hs, key) @ j &
    RevDHExp(x, tid, actor) @ i ==>
    #i < #j
"

// Handhsake property H1: Succesfully established sessionskeys should be the same amongst pairs.
// When two session keys are created in a connection, the sessionkeys should be the same
// The lemma specify; For all traces where a client and a server complete a handshake with each other, and non of the are corrupt, the sessionkeys should be the same
// ISSUE: The adversary can change the identifiers and troll the server
lemma H1_Establishing_the_same_session_keys:
"
  All C S client_session_id server_session_id keyC keyS #i #j.
    HandshakeComplete(C, S, 'client', keyC, <client_session_id, server_session_id>) @ #i 
    & HandshakeComplete(S, C, 'server', keyS, <client_session_id, server_session_id>) @ #j
    & not(Ex #p. Corrupt(C) @ p) 
    & not(Ex #q. Corrupt(S) @ q)
      ==> keyC = keyS
"

lemma H2_Session_key_secrecy:
"
  All actor peer role session_id key #i #j.
    SessionKey(actor, peer, role, session_id, key, 'auth') @ i 
    & K(key) @ j
     ==>
      (Ex #p. Corrupt(actor) @ p)
    | (Ex #q. Corrupt(peer) @ q)
"

/* If the client has accepted authentication from the server, then the server must have sent their identity on a trace with equal handshake history*/
/* ISSUE: We cant be sure on C and S... */
lemma H3_Authentication:
"
  All actor1 actor2 role1 session_id HandshakeHistory key #i.
    CommitAuth(actor1, actor2, role1, session_id, HandshakeHistory, key) @ i
    & not(Ex #p. Corrupt(actor1) @ p) 
    & not(Ex #q. Corrupt(actor2) @ q)
      ==> (Ex role2 #r. Running(actor2, role2, session_id, HandshakeHistory, key) @ r)
"

// ISSUE: The adversary can change the identifiers and troll the server
lemma H4_Unique_session_keys:
"
  All actor1 actor2 peer1 peer2 role key session_id1 session_id2 auth1 auth2 #i #j.
    SessionKey(actor1, peer1, role, session_id1, key, auth1) @ i & SessionKey(actor2, peer2, role, session_id2, key, auth2) @ j
      ==>
        #i = #j
        | (Ex #p. Corrupt(actor1) @ p)
        | (Ex #q. Corrupt(actor2) @ q)
        | (Ex #p. Corrupt(peer1) @ p)
        | (Ex #q. Corrupt(peer2) @ q)
"

lemma H6_Forward_secrecy:
"
All C S key nonce #i #j.
  HandshakeComplete(C, S, 'client', key, nonce) @ i 
  & HandshakeComplete(S, C, 'server', key, nonce) @ j
  & ((Ex #p. Corrupt(C) @ p & #j < #p) 
  | (Ex #q. Corrupt(S) @ q & #j < #q))
  & not((Ex #k. K(key) @ k & #k < #j))
  ==>
    not((Ex #k. K(key) @ k))
"

lemma H8_Prot_Endpoint_Identity:
"
  All actor1 actor2 cert session_id #i.
    ClientCert(actor1, actor2, session_id, cert) @ i
    & not(Ex #p. Corrupt(actor1) @ p) 
    & not(Ex #q. Corrupt(actor2) @ q)
      ==> not(Ex #r. K(cert) @ r)
"

end