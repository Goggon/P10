theory handshake
begin

builtins: hashing, diffie-hellman, symmetric-encryption, asymmetric-encryption, signing, natural-numbers

functions: HKDFExpand/1, hmac/1, h1/1

macros: handshakeCryptoHeader() = </*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'>>,
        protocolVersion() = <'254', '253'>

/**** IMPORTANT  ****
  In DTLS 1.3, the message transcript is computed over the original TLS
  1.3-style Handshake messages without the message_seq,
  fragment_offset, and fragment_length values.  Note that this is a
  change from DTLS 1.2 where those values were included in the
  transcript.
********************/

// Adversary power
rule Reveal_DHExp:
  [ DHExp(~x, ~tid, $A) ] --[ RevDHExp(~x, ~tid, $A), Corrupt($A) ]-> [ Out(~x) ]

rule Reveal_LTK:
  [ !Ltk($A, ~ltk) ] --[ Corrupt($A) ]-> [ Out(~ltk) ]

// Asym key setup
rule Register_pk:
    [ Fr(~ltk) ]
  --[ Reg($A) ]->
    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)), Out(pk(~ltk)) ]

// ClientHello
rule ClientHello:
  let
    ClientHello = 
      < /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ ~session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', 'g'^~a>
          >
        >
      >

    DTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ 1:nat,
        /*sequence_number*/ 1:nat,
        /*length*/ ~msg_len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <~msg_len, 1:nat, 1:nat, 1:nat>,
          ClientHello
        >
      >
  in
      [ Fr(~a),
        Fr(~session_id),
        Fr(~msg_len) ]
    --[ DH(~a, ~session_id, $C),
        Start($C, $S, 'client', ~session_id), /* We must make it a note that we are communicating with the server, so we can discard packages out of order*/ 
        Send($C, $S, 'CH', ~session_id),
        CH_ClientHello($C, $S, ~session_id, <'1', ClientHello>) ]->
      [ Out(<DTLSPlaintext, $C, $S>) /*clienthello plaintext*/,
        St_ClientHello($C, $S, ~a, ~session_id, <h1(<'1', ClientHello>)>), /*We need to save the handshake context*/
        DHExp(~a, ~session_id, $C),
        ClientSeqAndEpochCHC(~session_id, 1:nat %+ 1:nat, 1:nat, 1:nat, 1:nat) ]

// HelloRetryRequest
rule HelloRetryRequest:
  let
    /********** INCOMMING **********/
    ClientHello = 
      < 
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ client_session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', ga>
          >
        >
      >

    ClientDTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %epoch,
        /*sequence_number*/ %seq,
        /*length*/ len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <len, %seq, %off, %frag>,
          ClientHello
        >
      >
    /******************************/

    /********* HELLORETRYREQUEST ****************/
    HelloRetryRequest = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/        'HelloRetryRequest',
        /*CipherSuite*/     'CipherSuits',
        /*Extension*/ <
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <
              h1(<<'1', ClientHello>, 'HelloRetryRequest'>)
            >
          >
        >
      >

    DTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ 1:nat,
        /*sequence_number*/ 1:nat,
        /*length*/ ~msg_len,
        <
          /*Handshaketype*/   /*HandshakeType*/ '2', /*server_hello(2)*/
          <~msg_len, 1:nat, 1:nat, 1:nat>,
          HelloRetryRequest
        >
      >

    /*************************************/
  in
      [ Fr(~session_id),
        Fr(~msg_len),
        In(<ClientDTLSPlaintext, $C, $S>) /*clienthello plaintext*/ ]
    --[ Send($S, $C, 'HRR', ~session_id), Reach('HRR') ]->
      [ St_ServerHelloRetry($S, $C, ~session_id, h1(<<'1', ClientHello>, 'HelloRetryRequest'>), <h1(<'1', ClientHello>), <'2', HelloRetryRequest>>),
        RecordNumbersHHR(<%epoch, %seq>),
        Out(<DTLSPlaintext, $S, $C>),
        ServerSeqAndEpochSH(~session_id, 1:nat %+ 1:nat, 1:nat, %seq %+ 1:nat, %epoch) ]

// ClientHelloCookie
rule ClientHelloCookie:
  let
    /********* INCOMMING: HELLORETRYREQUEST ********/
    HelloRetryRequest = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/        'HelloRetryRequest',
        /*CipherSuite*/     'CipherSuits',
        /*Extension*/ <
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <
              cookie
            >
          >
        >
      >

    ServerDTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ len,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <len, %rec_seq, %off, %frag>,
          HelloRetryRequest
        >
      >

    /*************************************/

    /************* CLIENTHELLOCOOKIE ***********/
    ClientHelloCookie = 
      < 
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', 'g'^a>
          >,
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <cookie>
          >
        >
      >

    DTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %next_epoch,
        /*sequence_number*/ %next_seq,
        /*length*/ ~msg_len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>,
          ClientHelloCookie
        >
      >
    /*************************************/
  in
      [ Fr(~msg_len),
        ClientSeqAndEpochCHC(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        In(<ServerDTLSPlaintext, $S, $C>),
        St_ClientHello($C, $S, a, session_id, <ClientHello>) ]
    --[ Instance(session_id, $C, 'client'),
        Send($C, $S, 'CHC', session_id), Reach('CHC') ]->
      [ St_ClientHelloCookie($C, $S, a, session_id, <ClientHello, <'2', HelloRetryRequest>, <'1', ClientHelloCookie>>),
        Out(<DTLSPlaintext, $C, $S>),
        ClientSeqAndEpochCF(session_id, 1:nat, %next_epoch %+ 1:nat, %rec_seq %+ 1:nat, %rec_epoch) ]

// ServerHello
rule ServerHello:
  let
    /********** INCOMMING **********/
    ClientHelloCookie = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ client_session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareClientHello*/ <
            /*KeyshareEntry*/ <'g', ga>
          >,
          /*ExtensionType*/     '44', //(For cookie)
          <
            /*Cookie*/ <
              inc_cookie
            >
          >
        >
      >

    ClientDTLSPlaintext = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ len,
        <
          /*HandshakeType*/ '1', /*client_hello(1)*/
          <len, %rec_seq, %off, %frag>,
          ClientHelloCookie
        >
      >
    
    // We must remove the cookie in order to compare the ClientHellos
    ClientHandshakeToCompare = 
      <
        /*HandshakeType*/ '1', /*client_hello(1)*/
        <
          /*ProtocolVersion*/ protocolVersion(), 
          /*Random32*/ client_session_id, 
          /*CipherSuite*/ 'CipherSuits', 
          /*Extension*/ <
            /*ExtensionType*/ '51', 
            /*KeyshareClientHello*/ <
              /*KeyshareEntry*/ <'g', ga>
            >
          >
        >
      >
    /******************************/

    traffic_key = ga^~b

    /********** SERVERHELLO **********/
    ServerHello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ session_id, 
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareServerHello*/ <'g', 'g'^~b>
        >
      >

    DTLSPlaintextSH = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %next_epoch,
        /*sequence_number*/ %next_seq,
        /*length*/ ~msg_len,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>,
          ServerHello
        >
      >
    /******************************/
  in
      [ ServerSeqAndEpochSH(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        St_ServerHelloRetry($S, $C, session_id, cookie, <ClientHello, HelloRetryRequest>),
        RecordNumbersHHR(SHRecordNumbers),
        In(<ClientDTLSPlaintext, $C, $S>) /*clienthello plaintext*/,
        Fr(~b),
        Fr(~msg_len) ]
    --[ DH(~b, session_id, $S), 
        Neq('g', ga), Neq(ga, traffic_key), Reach('SH'), /* Ensure gb is not DH_Neutral */
        DHChal($S, session_id, 'g', ~b, ga, 'g'^~b, ga^~b),
        Eq(inc_cookie, cookie), Eq(h1(<ClientHandshakeToCompare, 'HelloRetryRequest'>), cookie),
        Start($S, $C, 'server', session_id), /* We must make it a note that we are communicating with the client, so we can discard packages out of order*/ 
        Send($S, $C, 'SH', session_id),
        Nonce($S, <client_session_id, session_id>),
        SH_ClientHello($S, $C, session_id, ClientHandshakeToCompare) ]->
      [ Out(<DTLSPlaintextSH, $S, $C>) /*serverhello plaintext*/,
        !Keys(<$S, $C, session_id, 'g'^~b, ga, traffic_key>),
        RecordNumbersSH(SHRecordNumbers, <%rec_epoch, %rec_seq>),
        St_ServerHello($S, $C, session_id, <ClientHello, HelloRetryRequest, <'1', ClientHelloCookie>, <'2', ServerHello>>),
        DHExp(~b, session_id, $S),
        ServerNonce($S, <client_session_id, session_id>),
        ServerSeqAndEpochEE(session_id, 1:nat, %next_epoch %+ 1:nat, 1:nat, %rec_epoch %+ 1:nat) /*Reset sequence number*/ ]

// EncryptedExtensions
rule EncryptedExtensions:
  let
    /********** ENCRYPTEDEXTENSION **********/
    EncryptedExtensions = 
    <
      /*Extension*/ <
          /*ExtensionType*/ '13', 
          /*EncryptedExtensions*/ 'encryptedExtensions'
      >
    >

    DTLSInnerPlaintextEE = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '8', /*encrypted_extensions(8)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>, 
          EncryptedExtensions
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextEE = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextEE
      >
    /******************************/
  in
      [ Fr(~msg_len),
        ServerSeqAndEpochEE(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        St_ServerHello($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello>),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'EE', session_id), Reach('EE') ]->
      [ Out(<DTLSCipherTextEE, $S, $C>) /*encryptedextensions encrypted*/,
        RequestCertificate($S, $C, session_id),
        St_EncryptedExtensions($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, <'8', EncryptedExtensions>>),
        ServerSeqAndEpochSCR(session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch) ]

// ServerCertificate
rule ServerCertificate:
  let
    /********** SERVERCERTIFICATE **********/
    %frag_max = 1:nat %+ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat
    ServerCertificate_1 = 
      <
        /*certificate_entry*/ 'ser'
      >

    DTLSInnerPlaintextSC_1 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_1, %next_seq, 1:nat, %frag_max>,
          ServerCertificate_1
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_1 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextSC_1
      >   

      ServerCertificate_2 = 
        <
          /*certificate_entry*/ 've'
        >

    DTLSInnerPlaintextSC_2 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_2, %next_seq, 1:nat %+ 1:nat, %frag_max>,  
          ServerCertificate_2
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_2 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextSC_2
      >   

    ServerCertificate_3 = 
      <
        /*certificate_entry*/ 'rC'
      >

    DTLSInnerPlaintextSC_3 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_3, %next_seq, 1:nat %+ 1:nat %+ 1:nat, %frag_max>, 
          ServerCertificate_3
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_3 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextSC_3
      >   

    ServerCertificate_4 = 
      <
        /*certificate_entry*/ 'er'
      >

    DTLSInnerPlaintextSC_4 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_4, %next_seq, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %frag_max>,  
          ServerCertificate_4
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_4 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextSC_4
      >  

    ServerCertificate_5 = 
      <
        /*certificate_entry*/ 't'
      >

    DTLSInnerPlaintextSC_5 = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '11', /*certificate(11)*/
          <msg_len_5, %next_seq, %frag_max, %frag_max>,  
          ServerCertificate_5
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextSC_5 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextSC_5
      >      

    // Reasembeled handshake record
    ServerCertificate = <ServerCertificate_1, ServerCertificate_2, ServerCertificate_3, ServerCertificate_4, ServerCertificate_5>
      
    /******************************/
  in
      [ Fr(msg_len_1),
        Fr(msg_len_2),
        Fr(msg_len_3),
        Fr(msg_len_4),
        Fr(msg_len_5),
        ServerSeqAndEpochSC(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        St_EncryptedExtensions($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions>),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'C', session_id), Reach('SC') ]->
      [ Out(<DTLSCipherTextSC_1, $S, $C>), /*servercertificate encrypted fragment 1*/
        Out(<DTLSCipherTextSC_2, $S, $C>), /*servercertificate encrypted fragment 2*/
        Out(<DTLSCipherTextSC_3, $S, $C>), /*servercertificate encrypted fragment 3*/
        Out(<DTLSCipherTextSC_4, $S, $C>), /*servercertificate encrypted fragment 4*/
        Out(<DTLSCipherTextSC_5, $S, $C>), /*servercertificate encrypted fragment 5*/
        ServerSeqAndEpochSCV(session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch),
        St_ServerCertificate($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>>) ]

// ServerCertificateVerify
rule ServerCertificateVerify:
  let
    /********** SERVERCERTIFICATEVERIFY **********/
    CertificateVerify = 
    <
      /*algorithm*/ $alg, 
      /*signature*/ sign(hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>>), ServerCertificate>), serverPrivateKey)
    >

    DTLSInnerPlaintextCV = 
      senc{<
        /*content*/ <
          /*HandshakeType*/ '15', /*certificate_verify(15)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>, 
          CertificateVerify
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >}traffic_key

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextCV
      >
    /******************************/
  in
      [ Fr(~msg_len),
        ServerSeqAndEpochSCV(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        !Ltk($S, serverPrivateKey),
        St_ServerCertificate($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>>),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'CV', session_id), Reach('SCV') ]->
      [ Out(<DTLSCipherTextCV, $S, $C>), /*servercertificateverify encrypted*/
        ServerSeqAndEpochSF(session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch),
        St_ServerCertificateVerify($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, <'11', ServerCertificate>, <'15', CertificateVerify>>) ]

// ServerFinished
rule ServerFinished:
  let
    /********** SERVERFINISHED **********/
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    ServerFinished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>)>)
      >

    DTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <~msg_len, %next_seq, 1:nat, 1:nat>, 
            ServerFinished
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /******************************/
  in
      [ Fr(~msg_len),
        ServerSeqAndEpochSF(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        St_ServerCertificateVerify($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>),
        ServerNonce($S, <client_session_id, session_id>) ]
    --[ Instance(session_id, $S, 'server'),
        Send($S, $C, 'SF', session_id), Reach('SF'),
        Running($S, 'server', <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>) /* Used to ensure peer authentication, if a client has accepted a servers indentity, then a server must have sent their identity on a session equal to the one sent by the client*/ ]->
      [ Out(<DTLSCipherTextSF, $S, $C>), /*server finished*/
        ServerFinished(<$S, $C, hmac(<finished_key, h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify>)>), <client_session_id, session_id>>),
        St_ServerFinished($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, <'20', ServerFinished>>),
        ServerSeqAndEpochACK(session_id, %next_seq %+ 1:nat, %next_epoch %+ 1:nat, %rec_seq, %rec_epoch),
        FinalKey($S, $C, finished_key) ]

// ServerCertificateRequest
rule ServerCertificateRequest:
  let
    CertificateRequest = 
      <
        /*certificate_request_context*/ //Empty length
        /*Extension*/ $client_alg
      >

    DTLSInnerPlaintextCR = 
      senc(<
        /*content*/ <
          /*HandshakeType*/ '13', /*certificate_request(13)*/
          <~msg_len, %next_seq, 1:nat, 1:nat>,
          CertificateRequest
        >, 
        /*zeros*/ <'0'>, 
        /*ContentType*/ '22'
      >, traffic_key)

    DTLSCipherTextCR = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextCR
      >

  in
      [ Fr(~msg_len),
        ServerSeqAndEpochSCR(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        RequestCertificate($S, $C, session_id),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>) ]
    --[ Instance(session_id, $S, 'server'),
        CertificateRequested('True') ]->
      [ CertificateRequested('True'),
        ServerSeqAndEpochSC(session_id, %next_seq %+ 1:nat, %next_epoch, %rec_seq, %rec_epoch),
        Out(<DTLSCipherTextCR, $S, $C>) /* server request certificate */ ]

// ServerNoCertificateRequest
rule ServerNoCertificateRequest:
    [ RequestCertificate($S, $C, session_id),
      ServerSeqAndEpochSCR(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch) ]
  --[ CertificateRequested('False') ]->
    [ CertificateRequested('False'),
      ServerSeqAndEpochSC(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch) ]




//ClientFinished
rule ClientFinishedNoAuth:
  let
    traffic_key = gb^a

    /********** INCOMMING: SERVERHELLO **********/
    ServerHello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ server_session_id,  
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
            /*ExtensionType*/ '51', 
            /*KeyshareServerHello*/ <'g', gb>
        >
      >

    DTLSPlaintextSH = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ lenSH,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <lenSH, %rec_seq, %offSH, %fragSH>,
          ServerHello
        >
      >
    /********************************************/

    /********** INCOMMING: ENCRYPTEDEXTENSION **********/
    EncryptedExtensions = 
      <
        /*Extension*/ <
            /*ExtensionType*/ '13', 
            /*EncryptedExtensions*/ 'encryptedExtensions'
        >
      >

    DTLSCipherTextEE = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '8', /*encrypted_extensions(8)*/
            <lenEE, 1:nat, %offEE, %fragEE>, 
            EncryptedExtensions
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >

    /********************************************/

    /********** INCOMMING: SERVERCERTIFICATE **********/
    DTLSCipherTextSC_1 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_1, 1:nat %+ 1:nat, %offSC_1, %fragSC_1>,
            ServerCertificate_1
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_2 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_2, 1:nat %+ 1:nat, %offSC_2, %fragSC_2>,
            ServerCertificate_2
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_3 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_3, 1:nat %+ 1:nat, %offSC_3, %fragSC_3>,  
            ServerCertificate_3
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_4 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_4, 1:nat %+ 1:nat, %offSC_4, %fragSC_4>,  
            ServerCertificate_4
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >  

    DTLSCipherTextSC_5 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_5, 1:nat %+ 1:nat, %offSC_5, %fragSC_5>,  
            ServerCertificate_5
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >    

    // Reasembeled
    ServerCertificate = <ServerCertificate_1, ServerCertificate_2, ServerCertificate_3, ServerCertificate_4, ServerCertificate_5>
      
                  
    /******************************/

    /********** INCOMMING: SERVERCERTIFICATEVERIFY **********/
    CertificateVerify = 
    <
      /*algorithm*/ $alg, 
      /*signature*/ serverSignature //hmac(<h1(<DTLSHandshake_CH, DTLSSH, DTLSEE, DTLSSC>), 'serverCert'>) 
    >

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <lenSCV, 1:nat %+ 1:nat %+ 1:nat, %offSCV, %fragSCV>, 
            CertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: SERVERFINISHED **********/
    ServerFinished = 
      <
        /*verify_data*/ server_finished
      >
      
    ServerDTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <lenSF, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %offSF, %fragSF>, 
            ServerFinished
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /********************************************/

    /********** CLIENTFINISHED **********/
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    ClientFinished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>>)>)
      >

    DTLSCipherText =  
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <~msg_len, %next_seq, 1:nat, 1:nat>, 
            ClientFinished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /**********************************/
  in
      [ Fr(~msg_len),
        St_ClientHelloCookie($C, $S, a, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie>),
        ClientSeqAndEpochCF(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        !Pk($S, serverPublicKey),
        In(<DTLSPlaintextSH, $S, $C>) /*serverhello plaintext*/,
        In(<DTLSCipherTextEE, $S, $C>) /*encryptedextensions encrypted*/,
        In(<DTLSCipherTextSC_1, $S, $C>), /*servercertificate encrypted fragment 1*/
        In(<DTLSCipherTextSC_2, $S, $C>), /*servercertificate encrypted fragment 2*/
        In(<DTLSCipherTextSC_3, $S, $C>), /*servercertificate encrypted fragment 3*/
        In(<DTLSCipherTextSC_4, $S, $C>), /*servercertificate encrypted fragment 4*/
        In(<DTLSCipherTextSC_5, $S, $C>), /*servercertificate encrypted fragment 5*/
        In(<DTLSCipherTextCV, $S, $C>), /*servercertificateverify encrypted*/
        In(<ServerDTLSCipherTextSF, $S, $C>) /*server finished*/ ]
    --[ Instance(session_id, $C, 'client'),
        HandshakeComplete($C, $S, 'client', traffic_key, <session_id, server_session_id>), Reach('CFNoAuth'),
        DHChal($S, session_id, 'g', a, 'g'^a, gb, gb^a),
        SessionKey($C, $S, 'client', session_id, traffic_key, 'auth'),
        FragmentsInOrder(%offSC_1, %offSC_2, %offSC_3, %offSC_4, %offSC_5),
        Nonce($C, <session_id, server_session_id>),
        CommitAuth($C, $S, 'client', <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>>), /* Used to ensure peer authentication, if a client has accepted a servers indentity, then a server must have sent their identity on a session equal to the one sent by the client*/
        Neq('g', gb), Neq(gb, traffic_key), /* Ensure gb is not DH_Neutral */
        Eq(hmac(<finished_key, h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>>)>), server_finished), 
        Eq(verify(serverSignature, hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>>), ServerCertificate>), serverPublicKey), true),
        Send($C, $S, 'CF', session_id) ]->
      [ Out(<DTLSCipherText, $C, $S>) /*client finished*/,
        //ClientSessionHandshakeHistory($C, $S, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', CertificateVerify>, <'20', ServerFinished>>),
        ClientSeqAndEpochAPP(session_id, 1:nat, %next_epoch %+ 1:nat, 1:nat, %rec_epoch %+ 1:nat), /* Reset sequence */
        !ClientKeys(<$C, $S, session_id, 'g'^a, gb, traffic_key>),
        !ClientSessionKey($C, $S, session_id, finished_key) ]

//ClientFinished
rule ClientFinishedAuth:
  let
    traffic_key = gb^a

    /********** INCOMMING: SERVERHELLO **********/
    ServerHello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ server_session_id,  
        /*CipherSuite*/ 'CipherSuits', 
        /*Extension*/ <
            /*ExtensionType*/ '51', 
            /*KeyshareServerHello*/ <'g', gb>
        >
      >

    DTLSPlaintextSH = 
      <
        /*ContentType*/ '22',
        /*epoch*/ %rec_epoch,
        /*sequence_number*/ %rec_seq,
        /*length*/ lenSH,
        <
          /*HandshakeType*/ '2', /*server_hello(2)*/
          <lenSH, %rec_seq, %offSH, %fragSH>,
          ServerHello
        >
      >
    /********************************************/

    /********** INCOMMING: ENCRYPTEDEXTENSION **********/
    EncryptedExtensions = 
      <
        /*Extension*/ <
            /*ExtensionType*/ '13', 
            /*EncryptedExtensions*/ 'encryptedExtensions'
        >
      >

    DTLSCipherTextEE = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '8', /*encrypted_extensions(8)*/
            <lenEE, 1:nat, %offEE, %fragEE>, 
            EncryptedExtensions
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >

    /********************************************/

    /********** INCOMMING ***********/
    CertificateRequest = 
      <
        /*certificate_request_context*/ //Empty length
        /*Extension*/ $client_alg
      >

    DTLSCipherTextCR = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '13', /*certificate_request(13)*/
            <lenCR, 1:nat %+ 1:nat, %offCR, %fragCR>,
            CertificateRequest
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /******************************/

    /********** INCOMMING: SERVERCERTIFICATE **********/
    DTLSCipherTextSC_1 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_1, 1:nat %+ 1:nat %+ 1:nat, %offSC_1, %fragSC_1>,
            ServerCertificate_1
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_2 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_2, 1:nat %+ 1:nat %+ 1:nat, %offSC_2, %fragSC_2>,
            ServerCertificate_2
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_3 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_3, 1:nat %+ 1:nat %+ 1:nat, %offSC_3, %fragSC_3>,  
            ServerCertificate_3
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >   

    DTLSCipherTextSC_4 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_4, 1:nat %+ 1:nat %+ 1:nat, %offSC_4, %fragSC_4>,  
            ServerCertificate_4
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >  

    DTLSCipherTextSC_5 = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenSC_5, 1:nat %+ 1:nat %+ 1:nat, %offSC_5, %fragSC_5>,  
            ServerCertificate_5
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >    

    // Reasembeled
    ServerCertificate = <ServerCertificate_1, ServerCertificate_2, ServerCertificate_3, ServerCertificate_4, ServerCertificate_5>            
    /******************************/

    /********** INCOMMING: SERVERCERTIFICATEVERIFY **********/
    ServerCertificateVerify = 
      <
        /*algorithm*/ $alg, 
        /*signature*/ serverSignature //hmac(<h1(<DTLSHandshake_CH, DTLSSH, DTLSEE, DTLSSC>), 'serverCert'>) 
      >

    DTLSCipherTextSCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <lenSCV, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %offSCV, %fragSCV>, 
            ServerCertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: SERVERFINISHED **********/
    ServerFinished = 
      <
        /*verify_data*/ server_finished
      >
      
    ServerDTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <lenSF, 1:nat %+ 1:nat %+ 1:nat %+ 1:nat %+ 1:nat, %offSF, %fragSF>, 
            ServerFinished
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /********************************************/

    /********** CERTIFICATE **********/
    ClientCertificate = 
      <
        /*certificate_entry*/ 'clientCert'
      >

    DTLSCipherTextCC = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <~msg_len_1, %next_seq, 1:nat, 1:nat>,  
            ClientCertificate
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** CERTIFICATEVERIFY **********/
    CertificateVerify = 
      <
        /*algorithm*/ $client_alg, 
        /*signature*/ sign(hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>, <'20', ServerFinished>>), 'clientCert'>), clientPrivateKey)
      >

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <~msg_len_2, %next_seq %+ 1:nat, 1:nat, 1:nat>, 
            CertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** CLIENTFINISHED **********/
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    ClientFinished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>>)>)
      >

    DTLSCipherText =  
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <~msg_len, %next_seq %+ 1:nat %+ 1:nat, 1:nat, 1:nat>, 
            ClientFinished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /**********************************/
  in
      [ Fr(~msg_len), Fr(~msg_len_1), Fr(~msg_len_2),
        St_ClientHelloCookie($C, $S, a, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie>),
        ClientSeqAndEpochCF(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        !Pk($S, serverPublicKey),
        In(<DTLSPlaintextSH, $S, $C>), /*serverhello plaintext*/
        In(<DTLSCipherTextEE, $S, $C>), /*encryptedextensions encrypted*/
        In(<DTLSCipherTextSC_1, $S, $C>), /*servercertificate encrypted fragment 1*/
        In(<DTLSCipherTextSC_2, $S, $C>), /*servercertificate encrypted fragment 2*/
        In(<DTLSCipherTextSC_3, $S, $C>), /*servercertificate encrypted fragment 3*/
        In(<DTLSCipherTextSC_4, $S, $C>), /*servercertificate encrypted fragment 4*/
        In(<DTLSCipherTextSC_5, $S, $C>), /*servercertificate encrypted fragment 5*/
        In(<DTLSCipherTextSCV, $S, $C>), /*servercertificateverify encrypted*/
        In(<ServerDTLSCipherTextSF, $S, $C>), /*server finished*/
        In(<DTLSCipherTextCR, $S, $C>),
        !Ltk($C, clientPrivateKey) ]
    --[ Instance(session_id, $C, 'client'),
        HandshakeComplete($C, $S, 'client', traffic_key, <session_id, server_session_id>), Reach('CFAuth'),
        DHChal($S, session_id, 'g', a, 'g'^a, gb, gb^a),
        SessionKey($C, $S, 'client', session_id, traffic_key, 'auth'),
        FragmentsInOrder(%offSC_1, %offSC_2, %offSC_3, %offSC_4, %offSC_5),
        Nonce($C, <session_id, server_session_id>),
        Running($C, 'client', <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>, <'20', ServerFinished>>),
        CommitAuth($C, $S, 'client', <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>>), /* Used to ensure peer authentication, if a client has accepted a servers indentity, then a server must have sent their identity on a session equal to the one sent by the client*/
        Neq('g', gb), Neq(gb, traffic_key), /* Ensure gb is not DH_Neutral */
        Eq(hmac(<finished_key, h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>>)>), server_finished), 
        Eq(verify(serverSignature, hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>>), ServerCertificate>), serverPublicKey), true),
        Send($C, $S, 'CF', session_id) ]->
      [ Out(<DTLSCipherText, $C, $S>) /*client finished*/,
        Out(<DTLSCipherTextCC, $C, $S>), 
        Out(<DTLSCipherTextCV, $C, $S>),
        //ClientSessionHandshakeHistory($C, $S, session_id,  <ClientHello, HelloRetryRequest, ClientHelloCookie, <'2', ServerHello>, <'8', EncryptedExtensions>, <'11', ServerCertificate>, <'15', ServerCertificateVerify>, <'20', ServerFinished>>),
        ClientSeqAndEpochAPP(session_id, 1:nat, %next_epoch %+ 1:nat, 1:nat, %rec_epoch %+ 1:nat), /* Reset sequence */
        !ClientKeys(<$C, $S, session_id, 'g'^a, gb, traffic_key>),
        !ClientSessionKey($C, $S, session_id, finished_key) ]

// Ack
rule Ack:
  let
    /********** INCOMMING: CERTIFICATE **********/
    ClientCertificate = 
      <
        /*certificate_entry*/ 'clientCert'
      >
    
    DTLSCipherTextCC = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '11', /*certificate(11)*/
            <lenCC, %rec_seq, %offCC, %fragCC>,  
            ClientCertificate
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: CERTIFICATEVERIFY **********/
    ClientCertificateVerify = 
      <
        /*algorithm*/ $client_alg, 
        /*signature*/ clientSignature
      >

    DTLSCipherTextCV = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc{<
          /*content*/ <
            /*HandshakeType*/ '15', /*certificate_verify(15)*/
            <lenCV, %rec_seq %+ 1:nat, %offCV, %fragCV>, 
            ClientCertificateVerify
          >, 
          /*zeros*/ <'0'>, 
          /*ContentType*/ '22'
        >}traffic_key
      >
    /******************************/

    /********** INCOMMING: FINISHED **********/
    DTLSCipherTextCF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <lenCF, %rec_seq %+ 1:nat %+ 1:nat, %offCF, %fragCF>, 
            client_finished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /******************************/

    /********** ACK ***************/
    DTLSCipherTextACK = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <CHRecordNumbers, CHCRecrodNumbers, <1:nat %+ 1:nat %+ 1:nat, %rec_seq>, <1:nat %+ 1:nat %+ 1:nat, %rec_seq %+ 1:nat>, <1:nat %+ 1:nat %+ 1:nat, %rec_seq %+ 1:nat %+ 1:nat>>, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '26'
        >, traffic_key)
      >
    /*********************/
  in
      [ In(<DTLSCipherTextCC, $C, $S>),
        In(<DTLSCipherTextCV, $C, $S>),
        In(<DTLSCipherTextCF, $C, $S>),
        RecordNumbersSH(CHRecordNumbers, CHCRecrodNumbers),
        ServerSeqAndEpochACK(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        !Pk($C, clientPublicKey),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>),
        FinalKey($S, $C, finished_key),
        St_ServerFinished($S, $C, session_id, <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>),
        ServerFinished(<$S, $C, server_finished, nonce>),
        CertificateRequested(auth_status) ]
    --[ Instance(session_id, $S, 'server'),
        Eq(client_finished, server_finished), 
        Eq(auth_status, 'True'), Reach('ACK'),
        Eq(verify(clientSignature, hmac(<h1(<ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>), 'clientCert'>), clientPublicKey), true),
        CommitAuth($S, $C, 'server', <ClientHello, HelloRetryRequest, ClientHelloCookie, ServerHello, EncryptedExtensions, ServerCertificate, CertificateVerify, ServerFinished>),
        HandshakeComplete($S, $C, 'server', traffic_key, nonce),
        SessionKey($S, $C, 'server', session_id, traffic_key, 'auth'),
        Send($S, $C, 'ACK', session_id) ]->
      [ Out(DTLSCipherTextACK), 
        !ServerSessionKey($S, $C, session_id, finished_key) ]
      
// AckNoAuth
rule AckNoAuth:
  let
    /****** INCOMMING: CLIENTFINISH ******/
    DTLSCipherText = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <
            /*HandshakeType*/ '20', /*finished(20)*/
            <len, %rec_seq, %off, %frag>, 
            client_finished
          >, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '22'
        >, traffic_key)
      >
    /************************************/

    /********** ACK ***************/
    DTLSCipherTextACK = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ senc(<
          /*content*/ <CHRecordNumbers, CHCRecrodNumbers, <1:nat %+ 1:nat %+ 1:nat, %rec_seq>>, 
          /*zeros*/ <'0', '0'>, 
          /*ContentType*/ '26'
        >, traffic_key)
      >
    /*********************/
  in
      [ In(<DTLSCipherText, $C, $S>),
        ServerSeqAndEpochACK(session_id, %next_seq, %next_epoch, %rec_seq, %rec_epoch),
        RecordNumbersSH(CHRecordNumbers, CHCRecrodNumbers),
        !Keys(<$S, $C, session_id, gb, ga, traffic_key>),
        FinalKey($S, $C, finished_key),
        ServerFinished(<$S, $C, server_finished, nonce>),
        CertificateRequested(auth_status) ]
    --[ Instance(session_id, $S, 'server'),
        Eq(client_finished, server_finished), Eq(auth_status, 'False'), Reach('ACKNoAuth'),
        HandshakeComplete($S, $C, 'server', traffic_key, nonce),
        SessionKey($S, $C, 'server', session_id, traffic_key, 'not_auth'),
        Send($S, $C, 'ACK', session_id) ]->
      [ Out(DTLSCipherTextACK), 
        !ServerSessionKey($S, $C, session_id, finished_key) ]

rule ClientAppAck:
  [ !ClientSessionKey($C, $S, session_id, key),
    In(DTLSCipherTextACK),
    Fr(~data), Fr(~len) ]
--[ SendMsg($C, $S, ~data, key, ~len) ]->
  [ Out(senc(<~data, ~len>, key)) ]
        
rule ClientApp:
    [ !ClientSessionKey($C, $S, session_id, key),
      In(senc(<inc_data, inc_len>, key)),
      Fr(~data), Fr(~len) ]
  --[ ReceivedMsg($C, $S, inc_data, key, inc_len),
      SendMsg($C, $S, ~data, key, ~len) ]->
    [ Out(senc(<~data, ~len>, key)) ]

rule ServerApp:
    [ !ServerSessionKey($S, $C, session_id, key),
      In(senc(<inc_data, inc_len>, key)),
      Fr(~data), Fr(~len) ]
  --[ ReceivedMsg($S, $C, inc_data, key, inc_len),
      SendMsg($S, $C, ~data, key, ~len) ]->
    [ Out(senc(<~data, ~len>, key)) ]


// Restriction to allow for equality checks
restriction Equal:
"
  All x y #i.
    Eq(x, y) @ #i ==> x = y
"

// Restriction made to allow for inequality checks
restriction Not_equal:
"
  All x y #i.
    Neq(x, y) @ #i ==> not(x = y)
"

// Restriction only allow each actor to register one longterm-key
restriction Only_one_ltk_per_actor:
"
  All A #i #j.
    Reg(A) @ i & Reg(A) @ j ==> #i = #j
"

// Debug restriction to only have one client active in the system
// The adversary can act as other client from the active clients point of view
restriction DEBUG_Only_one_session_client:
"
  All a1 a2 a3 a4 sid1 sid2 #i #j. 
    Start(a1, a2, 'client', sid1) @ i & Start(a3, a4, 'client', sid2) @ j ==> #i = #j
"

// Debug restriction to only have one server active in the system
// This is less likely to be realistic, and should not be activeated in the general scheme of things
restriction DEBUG_Only_one_session_server:
"
  All a1 a2 a3 a4 sid1 sid2 #i #j. 
    Start(a1, a2, 'server', sid1) @ i & Start(a3, a4, 'server', sid2) @ j ==> #i = #j
"

/************** DH RESTRICTIONS ****************/
restriction dh_challenge:
"
  All actor1 actor2 random1 random2 g a b ga gb gab #i #j #r.
    DHChal(actor1, random1, g, a, ga, gb, gab) @ i 
    & DHChal(actor2, random2, g, b, ga, gb, gab) @ j
    & K(gab) @ r
      ==> 
        (Ex #p. (RevDHExp(a, random1, actor1) @ p & #p < #r)) | 
        (Ex #q. (RevDHExp(b, random2, actor2) @ q & #q < #r))
"

/*
restriction Only_once:
"
  All type #i.
    Reach(type) @ i ==> not(Ex #j. Reach(type) @j & not(#j = #i) )
"*/

/* DEBUG: Reach lemmas */ 
  lemma Reach_1:
  exists-trace
  "
    Ex #i. Reach('HRR') @ i
  "

  lemma Reach_2:
  exists-trace
  "
    Ex #i. Reach('CHC') @ i
  "
  lemma Reach_3:
  exists-trace
  "
    Ex #i. Reach('SH') @ i
  "
  lemma Reach_4:
  exists-trace
  "
    Ex #i. Reach('EE') @ i
  "
  lemma Reach_5:
  exists-trace
  "
    Ex #i. Reach('SC') @ i
  "
  lemma Reach_6:
  exists-trace
  "
    Ex #i. Reach('SF') @ i
  "

  lemma Reach_7:
  exists-trace
  "
    Ex #i. Reach('CFNoAuth') @ i
  "
  lemma Reach_8:
  exists-trace
  "
    Ex #i. Reach('ACKNoAuth') @ i
  "

  lemma Reach_9_5:
  exists-trace
  "
    Ex #i. CertificateRequested('True') @ i
  "

  lemma Reach_9:
  exists-trace
  "
    Ex #i #j. Reach('ACK') @ i & CertificateRequested('True') @ j
  "


  lemma Reach_10:
  exists-trace
  "
    Ex #i. Reach('CFAuth') @ i
  "
/*******************/


// Restriction R1: Restrict the actors to not instigate in more than one handshake with each others at a time
// This is relistic, since two honest actors to not want to attempt to instantiate two handshakes with each other at one time
// The restriction specify; If two session has been started, then the first session must have been complete before the new one start
restriction R1_Only_one_session_per_pair_at_a_time:
"
  All actor1 actor2 role session_id1 session_id2 #i #j.
    Start(actor1, actor2, role, session_id1) @ i & Start(actor1, actor2, role, session_id2) @ j & i < j
      ==> Ex traffic_key #k. HandshakeComplete(actor1, actor2, role, traffic_key, <session_id1, session_id2>) @ k & k < j & i < k
"

// Restriction R2: Restrict the actors to not make sessions with them selves
// The restriction is self explanitory
// The restriction specify; Actors may not start a session with them self
restriction R2_Dont_essablish_session_with_self:
"
  All actor1 actor2 role session_id #i.
    Start(actor1, actor2, role, session_id) @ #i & actor1 = actor2 ==> F
"

// Restriction R3: Dont resend messages. If a message that has already been processed is received again, ignore it.
// The restriction is a measure taken directly from the specification to not allow for replay attacks
// The restriction specify; If a message type is send twich on the same session id, then it must happen at the same time (it has in fact only been send once)
restriction R3_Dont_resend_messages:
"
  All actor1 actor2 msg_type session_id #i #j.
    Send(actor1, actor2, msg_type, session_id) @ #i & Send(actor1, actor2, msg_type, session_id) @ #j ==> #i = #j
"

// Restriction R4: Fragment offsets must be in the correct order. 
// All traces should only process messages in the correct order accoding to offset. In the model offset is defined as natural numbers starting 
// from the number 1.
// The restriction specify; If fragments are received, they should be in the order frag_offset_1 is the lowest and frag_offset_5 is the highest
restriction R4_Fragments_in_order:
"
  All %frag_offset_1 %frag_offset_2 %frag_offset_3 %frag_offset_4 %frag_offset_5 #i.
    FragmentsInOrder(%frag_offset_1, %frag_offset_2, %frag_offset_3, %frag_offset_4, %frag_offset_5) @ i
      ==> %frag_offset_1  %frag_offset_2 & %frag_offset_2  %frag_offset_3 & %frag_offset_3  %frag_offset_4 & %frag_offset_4  %frag_offset_5
"
/*
restriction R5_Session_id_invariant:
"
  All session_id actor role #i.
    Instance(session_id, actor, role) @ i
      ==> (Ex peer #j. Start(actor, peer, role, session_id) @ j & (#j < #i))
      
"*/
restriction R6_only_one_start_per_tid:
"
  All session_id actor1 actor2 peer1 peer2 role1 role2 #i #j.
    Start(actor1, peer1, role1, session_id) @ i & Start(actor2, peer2, role2, session_id) @ j 
      ==> #i = #j
"

restriction R7_dh_invariant:
"
  All tid actor x #i. RevDHExp(x, tid, actor)@i ==>
    Ex #j. DH(x, tid, actor)@j & #j < #i 
"

restriction R8_one_dh_per_x:
"
  All tid tid2 x actor actor2 #i #j.
    DH(x, tid, actor) @ i & DH(x, tid2, actor2) @ j ==> #i = #j
"

restriction R9_rev_dh_before_hs:
"
  All tid actor role hs x #i #j.
    Running(actor, role, hs) @ j &
    RevDHExp(x, tid, actor) @ i ==>
    #i < #j
"

// Validation V1: Reachability lemma
// A handshake must be able to be started AND ended from both the client and the servers perspective without either being corrupt or the adversary knowing the traffic key
// if the adversary knows the traffic_key, or either actor is corrupt, the adversary can makes this lemma trivially true
// The lemma specify; There must exists a time where both the server and client has started a session and ended is successfully, while not being corrupt and with the 
// adversary not knowing the traffic key. 
lemma V1_Reachability_with_both_actors[use_induction]:
  exists-trace
  "Ex C S client_session_id server_session_id traffic_key #i #j #k #l. 
    Start(C, S, 'client', client_session_id) @ i & Start(S, C, 'server', server_session_id) @ j
    & HandshakeComplete(C, S, 'client', traffic_key, <client_session_id, server_session_id>) @ k & HandshakeComplete(S, C, 'server', traffic_key, <client_session_id, server_session_id>) @ l
    & not(Ex #p. Corrupt(C) @ p) 
    & not(Ex #q. Corrupt(S) @ q)
    & not(Ex #r. K(traffic_key) @ r)
  "

/* Validation V2: Cookie validations */

  // We must not skip the cookie exchange
  // All handshakes should perform a cookie exchange, and such an SH cannot happen without a cookie exchange earliere on the same session
  // The lemma specify; 
  lemma V2_1_No_SH_without_HRR:
    "
      All C S session_id #i.
        Send(S, C, 'SH', session_id) @ i ==> Ex #j. Send(S, C, 'HRR', session_id) @ j & #j < #i
    "
  
  // 
  // The lemma specify; 
  lemma V2_2_CH_before_CHC:
    "
      All C S session_id1 #i.
        Send(S, C, 'SH', session_id1) @ #i
        ==>
          (Ex session_id2 content #j #k #l. Send(C, S, 'CH', session_id2) @ j 
          & #j < #i
          & CH_ClientHello(C, S, session_id2, content) @ k 
          & SH_ClientHello(S, C, session_id1, content) @ l)
    "


/***********************************/
// Validation V3: The trace including an authenticated client should exist
// It should be possible to successfully authenticate the client. The authentication lemma ensures that all authentications are valid.
// The lemma specify; There exsits a trace, where the server essablish a session key with an authenticated client
lemma V3_It_is_possible_to_auth_the_client:
exists-trace
  "
    Ex C S session_id traffic_key #i.
      SessionKey(S, C, 'server', session_id, traffic_key, 'auth') @ i
  "

// Validation V4: The trace including an unauthenticated client should exist
// It should be possible to successfully complete a handshake with an unauthenticated client.
// The lemma specify; There exsits a trace, where the server essablish a session key with an unauthenticated client
lemma V4_It_is_possible_to_not_auth_the_client:
exists-trace
  "
    Ex C S session_id traffic_key #i.
      SessionKey(S, C, 'server', session_id, traffic_key, 'not_auth') @ i
  "

// Handhsake property H1: Succesfully established sessionskeys should be the same amongst pairs.
// When two session keys are created in a connection, the sessionkeys should be the same
// The lemma specify; For all traces where a client and a server complete a handshake with each other, and non of the are corrupt, the sessionkeys should be the same
// ISSUE: The adversary can change the identifiers and troll the server
lemma H1_Establishing_the_same_session_keys:
"
  All C S client_session_id server_session_id keyC keyS #i #j.
    HandshakeComplete(C, S, 'client', keyC, <client_session_id, server_session_id>) @ #i 
    & HandshakeComplete(S, C, 'server', keyS, <client_session_id, server_session_id>) @ #j
    & not(Ex #p. Corrupt(C) @ p) 
    & not(Ex #q. Corrupt(S) @ q)
      ==> keyC = keyS
"

lemma H2_Session_key_secrecy[reuse]:
"
  All actor peer role session_id key #i.
  SessionKey(actor, peer, role, session_id, key, 'auth') @ i 
    & not(Ex #p. Corrupt(actor) @ p) 
    & not(Ex #q. Corrupt(peer) @ q) 
     ==>
       not(Ex #j. K(key) @ j)
"

/* If the client has accepted authentication from the server, then the server must have sent their identity on a trace with equal handshake history*/
/* ISSUE: We cant be sure on C and S... */
lemma H3_Authentication[reuse]:
"
  All C S HandshakeHistory #i.
    CommitAuth(C, S, 'client', HandshakeHistory) @ i
    & not(Ex #p. Corrupt(C) @ p) 
    & not(Ex #q. Corrupt(S) @ q)
      ==> (Ex #r. Running(S, 'server', HandshakeHistory) @ r)
"

// ISSUE: The adversary can change the identifiers and troll the server
lemma H4_Unique_session_keys[reuse]:
"
  All actor1 actor2 peer1 peer2 role key session_id1 session_id2 auth1 auth2 #i #j.
    SessionKey(actor1, peer1, role, session_id1, key, auth1) @ i & SessionKey(actor2, peer2, role, session_id2, key, auth2) @ j
      ==>
        #i = #j
        | (Ex #p. Corrupt(actor1) @ p)
        | (Ex #q. Corrupt(actor2) @ q)
        | (Ex #p. Corrupt(peer1) @ p)
        | (Ex #q. Corrupt(peer2) @ q)
"

lemma H6_Forward_secrecy[reuse]:
"
All C S key nonce #i #j.
  HandshakeComplete(C, S, 'client', key, nonce) @ i 
  & HandshakeComplete(S, C, 'server', key, nonce) @ j
  & ((Ex #p. Corrupt(C) @ p & #j < #p) 
  | (Ex #q. Corrupt(S) @ q & #j < #q))
  & not((Ex #k. K(key) @ k & #k < #j))
  ==>
    not((Ex #k. K(key) @ k))
"

lemma R1_Confidentiality:
"
  All actor1 actor2 msg session_key len #i #j.
    SendMsg(actor1, actor2, msg, session_key, len) @ i & K(msg) @ j ==> Ex #l. K(session_key) @ l 
"

lemma R2_Integrity:
"
  All actor1 actor2 msg session_key len #i.
    ReceivedMsg(actor1, actor2, msg, session_key, len) @ i & not(Ex #l. K(session_key) @ l & #l < #i) 
      ==> Ex #j. SendMsg(actor2, actor1, msg, session_key, len) @ j & #j < #i
"

lemma R3_Length_concealment:
"
  All actor1 actor2 msg session_key len #i.
    SendMsg(actor1, actor2, msg, session_key, len) @ i ==> not(Ex #j. K(len) @ j)
"
/*
lemma R4_Forward_Secrecy:
"
  All actor1 actor2 msg_old session_key_old session_key_new len #i #j #k.
    SendMsg(actor1, actor2, msg_old, session_key_old, len) @ i
    & not(K(msg_old) @ k)
    & RegisterSessionkey(session_key_new) @ j
    & #i < #j & #k < #j
      ==> not(Ex #l. K(msg_old) @ l)
"*/
end