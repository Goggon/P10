theory handshake
begin

builtins: hashing, symmetric-encryption, diffie-hellman, asymmetric-encryption, signing

//predicates: DH(g, gx) <=> Ex x. g^x = gx
functions: HKDF/1, HKDFExpand/1, HKDFExpand1/1, HKDFExpand2/1, hmac/1, mac/1, checksign/2, h1/1


rule ClientHello:
    let
        clienthello = < /*ProtocolVersion*/ <'254', '253'>, 
                        /*Random32*/ ~random, 
                        /*CipherSuite*/ $CipherSuits, 
                        /*Extension*/ <
                          /*ExtensionType*/ '51', 
                          /*KeyshareClientHello*/ <
                            /*KeyshareEntry*/ <'g', 'g'^~a>
                          >
                        >
                      >
        DTLSHandshake = <
                          /*length*/ '200',
                          /*message_seq*/ '0', 
                          /*fragment_offset*/ '0', 
                          /*fragment_length*/ '200', 
                          clienthello
                        >
        DTLSPlaintext = <
                          /*epoch*/ '0', 
                          /*sequence_number*/ '0', 
                          /*length*/ '210', 
                          DTLSHandshake
                        >
    in
        [ Fr(~random),
          Fr(~a) ]
      --[ Running($C, $S) /* We must make it a note that we are communicating with the server, so we can discard packages out of order*/ ]->
        [ Out(<DTLSPlaintext, $C, $S>) /*clienthello plaintext*/,
          St_ClientHello($C, $S, ~random, ~a),
          ClientSessionHandshakeHistory(<$C, $S, <DTLSHandshake>>) /*We need to save the handshake context*/ ]

// ServerHello
rule ServerHello:
let
    serverhello = <
                    /*ProtocolVersion*/ <'254', '253'>, 
                    /*Random32*/ ~random, 
                    /*CipherSuite*/ $CipherSuits, 
                    /*Extension*/ <
                        /*ExtensionType*/ '51', 
                        /*KeyshareServerHello*/ <'g', 'g'^~b>
                    >
                >
    DTLSHandshake = <
                    /*length*/ '200', 
                    /*message_seq*/ '0', 
                    /*fragment_offset*/ '0', 
                    /*fragment_length*/ '200', 
                    serverhello
                >

    DTLSPlaintext = <
                    /*epoch*/ '0', 
                    /*sequence_number*/ '0', 
                    /*length*/ '210', 
                    DTLSHandshake
                >

    ClientDTLSHandshake = <
                            /*length*/ rec_messageLength, 
                            /*message_seq*/ '0', 
                            /*fragment_offset*/ rec_fragmentOffset, 
                            /*fragment_length*/ rec_fragmentLength, 
                            <
                              /*ProtocolVersion*/ <'254', '253'>, 
                              /*Random32*/ rec_clientRandom, 
                              /*CipherSuite*/ $CipherSuits, 
                              /*Extension*/ <
                                <
                                  /*ExtensionType*/ '51', 
                                  /*KeyshareClientHello*/ <'g', ga>
                                >
                              >
                            >
                          >

    ClientDTLSPlaintext = <
                            /*epoch*/ '0', 
                            /*sequence_number*/ '0', 
                            /*length*/ rec_recordLength,
                            ClientDTLSHandshake
                          >
in
    [ Fr(~b),
      Fr(~random),
      In(<ClientDTLSPlaintext, $C, $C>) /*clienthellocookie plaintext*/ ]
  --[ Neq('g', ga),
      Running($S, $C) /* We must make it a note that we are communicating with the client, so we can discard packages out of order*/ ]->
    [ Out(<DTLSPlaintext, $S, $C>) /*serverhello plaintext*/,
      St_server_sends_hello($S, $C, ga^~b, ~random, rec_clientRandom, 'Server_sent_hello_to_client_Send_encrypted_extensions'),
      Keys(<$S, $C, 'g'^~b, ga, ga^~b>),
      ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake, DTLSHandshake>>) ]


// EncryptedExtensions
rule EncryptedExtensions:
let
    encrypted_extensions = <
                            /*Extension*/ <
                                /*ExtensionType*/ '13', 
                                /*EncryptedExtensions*/ $EncryptedExtensions
                            >
                          >

    DTLSHandshake = <
                        /*length*/ '400', 
                        /*message_seq*/ '0', 
                        /*fragment_offset*/ '0', 
                        /*fragment_length*/ '400', 
                        encrypted_extensions
                    >

    DTLSInnerPlaintext = senc{<
                            /*content*/ DTLSHandshake, 
                            /*zeros*/ <'0'>, 
                            /*ContentType*/ '22'
                        >}traffic_key

    DTLSCipherText = </*unified_hdr*/ 
                        <
                          /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'> 
                        >, 
                        /*encrypted_record*/ DTLSInnerPlaintext
                    >
    
in
  [ St_server_sends_hello($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_hello_to_client_Send_encrypted_extensions'),
    ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake_CH, DTLSHandshake_SH>>) ]
--[  ]->
  [ Out(<DTLSCipherText, $S, $C>) /*encrypted extensions*/,
    St_server_sends_encrypted_extensions($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_encrypted_extensions_to_client_Send_certificate_request'),
    ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake_CH, DTLSHandshake_SH, DTLSHandshake>>) ]


// ServerCertificate
rule ServerCertificate:
let
    server_certificate = <
                            /*certificate_entry*/ $ServerCert
                        >

    DTLSHandshake = <
                    /*length*/ '2000', 
                    /*message_seq*/ '1', 
                    /*fragment_offset*/ '0', 
                    /*fragment_length*/ '2000', 
                    server_certificate
                    >
    DTLSInnerPlaintext = senc{<
                            /*content*/ DTLSHandshake, 
                            /*zeros*/ <'0'>, 
                            /*ContentType*/ '22'
                        >}traffic_key

    DTLSCipherText = <
                        /*unified_hdr*/ <
                            /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*L*/ '1', /*S*/ '1', /*E*/ <'1','0'>
                        >, 
                        /*encrypted_record*/ DTLSInnerPlaintext
                    >
    
in
    [ St_server_sends_encrypted_extensions($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_encrypted_extensions_to_client_Send_certificate_request'),
      ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake_CH, DTLSHandshake_SH, DTLSHandshake_EE>>) ]
  --[  ]->
    [ Out(<DTLSCipherText, $S, $C>) /*server certificate*/,
      St_server_sends_server_certificate($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_server_certificate_to_client_Send_server_certificate_verify'),
      ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake_CH, DTLSHandshake_SH, DTLSHandshake_EE, DTLSHandshake>>) ]


// CertificateVerify
rule CertificateVerify:
let
    certificate_verify = <
                            /*algorithm*/ $alg, 
                            /*signature*/ $signature //Transcript-Hash(Handshake Context, Certificate) /* TODO */
                        >

    DTLSHandshake = <
                        /*length*/ '500', 
                        /*message_seq*/ '2', 
                        /*fragment_offset*/ '0', 
                        /*fragment_length*/ '500', 
                        certificate_verify
                    >
    DTLSInnerPlaintext = senc{<
                            /*content*/ DTLSHandshake, 
                            /*zeros*/ <'0'>, 
                            /*ContentType*/ '22'
                        >}traffic_key

    DTLSCipherText = <
                        /*unified_hdr*/ <
                            /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'>
                        >, 
                        /*encrypted_record*/ DTLSInnerPlaintext
                    >
    
in
  [ St_server_sends_server_certificate($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_server_certificate_to_client_Send_server_certificate_verify'),
    ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake_CH, DTLSHandshake_SH, DTLSHandshake_EE, DTLSHandshake_SC>>)]
--[  ]->
  [ Out(<DTLSCipherText, $S, $C>) /*certificate verify*/,
    St_server_sends_certificate_verify($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_certificate_verify_to_client_Send_server_finished'),
    ServerSessionHandshakeHistory(<$S, $C, <ClientDTLSHandshake_CH, DTLSHandshake_SH, DTLSHandshake_EE, DTLSHandshake_SC, DTLSHandshake>>)]


// ServerFinished
rule ServerFinished:
let
    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    server_finished = <
                        /*verify_data*/  hmac(<finished_key, 
                                              h1(HandshakeContext)>)
                      >
    DTLSHandshake = <
                        /*length*/ '400', 
                        /*message_seq*/ '0', 
                        /*fragment_offset*/ '0', 
                        /*fragment_length*/ '400', 
                        server_finished
                    >
    DTLSInnerPlaintext = senc{<
                            /*content*/ DTLSHandshake, 
                            /*zeros*/ <'0'>, 
                            /*ContentType*/ '22'
                        >}traffic_key
    DTLSCipherText = <
                        /*unified_hdr*/ <
                            /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*E*/ <'1','0'>
                        >, 
                        /*encrypted_record*/ DTLSInnerPlaintext
                    >
    
in
    [ St_server_sends_certificate_verify($S, $C, traffic_key, random, rec_clientRandom, 'Server_sent_certificate_verify_to_client_Send_server_finished'),
      ServerSessionHandshakeHistory(<$S, $C, HandshakeContext>) ]
  --[  ]->
    [ Out(<DTLSCipherText, $S, $C>), /*server finished*/
      ServerFinished(<$S, $C,server_finished>) ]
    

//ClientFinished
rule ClientFinished:
    let
        traffic_key = gb^a

        finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

        client_finished = <
                            /*verify_data*/  hmac(<finished_key, 
                                                  h1(<DTLSPlaintext_CH, <
                                                    /*length*/ rec_SHMessageLength, 
                                                    /*message_seq*/ '0', 
                                                    /*fragment_offset*/ rec_SHfragmentOffset, 
                                                    /*fragment_length*/ rec_SHfragmentLength, 
                                                    <
                                                      /*ProtocolVersion*/ <'254', '253'>, 
                                                      /*Random32*/ rec_serverRandom, 
                                                      /*CipherSuite*/ $CipherSuits, 
                                                      /*Extension*/ <
                                                        /*ExtensionType*/ '51', 
                                                        /*KeyshareServerHello*/ <'g', gb>
                                                      >
                                                    >
                                                  >, ServerDTLSHandshakeEE, ServerDTLSHandshakeSC, ServerDTLSHandshakeSCV>)>)
                          >

        DTLSHandshake = <
                          /*length*/ '300', 
                          /*message_seq*/ '4', 
                          /*fragment_offset*/ '0', 
                          /*fragment_length*/ '300', 
                          client_finished
                        >

        DTLSInnerPlaintext = <
                                /*content*/ DTLSHandshake, 
                                /*zeros*/ <'0'>, 
                                /*ContentType*/ '22'
                            >
        DTLSCipherText =  <
                            /*unified_hdr*/ <
                              /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*E*/ <'1','0'>
                            >, 
                            /*encrypted_record*/ senc{DTLSInnerPlaintext}traffic_key
                          >

        /* INCOMMING MESSAGE */
        ServerDTLSPlaintext = <
                                /*epoch*/ '0', 
                                /*sequence_number*/ '0', 
                                /*length*/ rec_SHRecordLength, 
                                <
                                  /*length*/ rec_SHMessageLength, 
                                  /*message_seq*/ '0', 
                                  /*fragment_offset*/ rec_SHfragmentOffset, 
                                  /*fragment_length*/ rec_SHfragmentLength, 
                                  <
                                    /*ProtocolVersion*/ <'254', '253'>, 
                                    /*Random32*/ rec_serverRandom, 
                                    /*CipherSuite*/ $CipherSuits, 
                                    /*Extension*/ <
                                      /*ExtensionType*/ '51', 
                                      /*KeyshareServerHello*/ <'g', gb>
                                    >
                                  >
                                >
                              >
    

        ServerDTLSCipherTextEE = </*unified_hdr*/ 
                                  <
                                  /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'> //<- Expect epoch = 2 
                                  >, 
                                  /*encrypted_record*/ senc{<
                                    /*content*/ ServerDTLSHandshakeEE, 
                                    /*zeros*/ <'0'>, 
                                    /*ContentType*/ '22'
                                  >}traffic_key
                                >

        ServerDTLSHandshakeEE = <
                                  /*length*/ rec_EELength, 
                                  /*message_seq*/ '0', 
                                  /*fragment_offset*/ rec_EEFragmentOffset, 
                                  /*fragment_length*/ rec_EEFragmentLength, 
                                  <
                                    /*Extension*/ <
                                      /*ExtensionType*/ '13', 
                                      /*EncryptedExtensions*/ $EncryptedExtensions
                                    >
                                  >
                                >

        ServerDTLSCipherTextSC = <
                                  /*unified_hdr*/ <
                                    /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*L*/ '1', /*S*/ '1', /*E*/ <'1','0'>
                                  >, 
                                  /*encrypted_record*/ senc{<
                                    /*content*/ ServerDTLSHandshakeSC, 
                                    /*zeros*/ <'0'>, 
                                    /*ContentType*/ '22'
                                  >}traffic_key
                                >

        ServerDTLSHandshakeSC = <
                                /*length*/ rec_SCMessageLength, 
                                /*message_seq*/ '1', 
                                /*fragment_offset*/ rec_SCFragmentOffset, 
                                /*fragment_length*/ rec_SCFragmentLength, 
                                <
                                  /*certificate_entry*/ $ServerCert
                                >
                              >

        ServerDTLSCipherTextSCV = <
                                    /*unified_hdr*/ <
                                      /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'>
                                    >, 
                                    /*encrypted_record*/ senc{<
                                      /*content*/ ServerDTLSHandshakeSCV, 
                                      /*zeros*/ <'0'>, 
                                      /*ContentType*/ '22'
                                    >}traffic_key
                                  >

        ServerDTLSHandshakeSCV = <
                                  /*length*/ rec_SCVMessageLength, 
                                  /*message_seq*/ '2', 
                                  /*fragment_offset*/ rec_SCVFragmentOffset, 
                                  /*fragment_length*/ rec_SCVFragmentLength, 
                                  <
                                    /*algorithm*/ $alg, 
                                    /*signature*/ signature /* TODO */
                                  >
                                >

        ServerDTLSCipherTextSF = <
                                  /*unified_hdr*/ <
                                    /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*L*/ '1', /*E*/ <'1','0'>
                                  >, 
                                  /*encrypted_record*/ senc{<
                                    /*content*/ <
                                      /*length*/ rec_SFMessageLength, 
                                      /*message_seq*/ '3', 
                                      /*fragment_offset*/ rec_SFFragmentOffset, 
                                      /*fragment_length*/ rec_SFFragmentLength, 
                                      <
                                        /*verify_data*/ serverFinish
                                      >
                                    >, 
                                    /*zeros*/ <'0'>, 
                                    /*ContentType*/ '22'
                                  >}traffic_key
                                >

    in
        [ St_ClientHello($C, $S, random, a),
          In(<ServerDTLSPlaintext, $S, $C>) /*serverhello plaintext*/,
          In(<ServerDTLSCipherTextEE, $S, $C>) /*encrypted extensions*/,
          In(<ServerDTLSCipherTextSC, $S, $C>) /*server certificate*/,
          In(<ServerDTLSCipherTextSCV, $S, $C>) /*server certificate verify*/,
          In(<ServerDTLSCipherTextSF, $S, $C>), /*server finished*/
          ClientSessionHandshakeHistory(<$C, $S, <DTLSPlaintext_CH>>) ]
      --[ FinishedC($C, $S, traffic_key),
          HandshakeComplete($C, $S),
          Neq('g', gb),
          Eq(client_finished, serverFinish) ]->
        [ Out(<DTLSCipherText, $C, $S>) /*client finished*/]

rule Ack:
  let
    DTLSCipherText = <
                      /*unified_hdr*/ <
                        /*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*E*/ <'1','0'>
                      >, 
                      /*encrypted_record*/ senc{<
                        /*content*/ <
                          /*length*/ '300', 
                          /*message_seq*/ '4', 
                          /*fragment_offset*/ '0', 
                          /*fragment_length*/ '300', 
                          client_finished
                        >, 
                        /*zeros*/ <'0'>, 
                        /*ContentType*/ '22'
                      >}traffic_key
                    >
  in
    [ In(<DTLSCipherText, $C, $S>),
      Keys(<$S, $C, gb, ga, traffic_key>),
      ServerFinished(<$S, $C, server_finished>) ]
  --[ Eq(client_finished, server_finished),
      HandshakeComplete($S, $C),
      FinishedS($S, $C, traffic_key),
      Reach() ]->
    []

restriction Equal:
"
  All x y #i.
    Eq(x, y) @ #i ==> x = y
"

restriction Not_equal:
"
  All x y #i.
    Neq(x, y) @ #i ==> not(x = y)
"

restriction Discard_out_of_order_msg:
"
  not(Ex actor1 actor2 #i #j #k.
    Running(actor1, actor2) @ #i & HandshakeComplete(actor1, actor2) @ #j & Running(actor1, actor2) @ #k & #k < #j & #i < #k)
"
// Reachability lemma
lemma Reachable:
  exists-trace
  "Ex #i. Reach() @ i"


lemma Establishing_the_same_session_keys:
"
  All C S keyC keyS #i #j.
    FinishedC(C, S, keyC) @ #i & FinishedS(S, C, keyS) @ #j ==>  keyC = keyS
"

end