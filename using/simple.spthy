theory handshake
begin

builtins: hashing, diffie-hellman, symmetric-encryption

functions: HKDFExpand/1, hmac/1, h1/1

macros: handshakeCryptoHeader() = </*first three bits*/ <'0','0','1'>, /*C*/ '0', /*S*/ '1', /*E*/ <'1','0'>>,
        protocolVersion() = <'254', '253'>

rule Reveal_DHExp:
  [ DHExp(~x, ~tid, $A) ] --[ RevDHExp(~x, ~tid, $A), Corrupt($A) ]-> [ Out(~x) ]

rule ClientHello:
    let
        clienthello = 
          < /*ProtocolVersion*/ protocolVersion(), 
            /*Random32*/ ~random, 
            /*CipherSuite*/ $CipherSuits, 
            /*Extension*/ <
              /*ExtensionType*/ '51', 
              /*KeyshareClientHello*/ <
                /*KeyshareEntry*/ <'g', 'g'^~a>
              >
            >
          >

        DTLSHandshake = 
          <
            /*length*/ '200',
            /*message_seq*/ '0', 
            /*fragment_offset*/ '0', 
            /*fragment_length*/ '200', 
            clienthello
          >

        DTLSPlaintext = 
          <
            /*epoch*/ '0', 
            /*sequence_number*/ '0', 
            /*length*/ '210', 
            DTLSHandshake
          >
    in
        [ Fr(~random),
          Fr(~a),
          Fr(~session_id) ]
      --[ Start($C, $S, 'client', ~session_id), /* We must make it a note that we are communicating with the server, so we can discard packages out of order*/ 
          Send($C, $S, 'CH', ~session_id),
          DH(~session_id, $C, ~a) ]->
        [ Out(<DTLSPlaintext, $C, $S>) /*clienthello plaintext*/,
          St_ClientHello($C, $S, ~random, ~a, ~session_id),
          ClientSessionHandshakeHistory(<$C, $S, <DTLSHandshake>>) /*We need to save the handshake context*/,
          DHExp(~a, ~session_id, $C) ]

// ServerHello
rule ServerHello:
let
    

    ClientDTLSHandshake = 
      <
        /*length*/ rec_messageLength, 
        /*message_seq*/ '0', 
        /*fragment_offset*/ rec_fragmentOffset, 
        /*fragment_length*/ rec_fragmentLength, 
        <
          /*ProtocolVersion*/ protocolVersion(), 
          /*Random32*/ rec_clientRandom, 
          /*CipherSuite*/ $CipherSuits, 
          /*Extension*/ <
            <
              /*ExtensionType*/ '51', 
              /*KeyshareClientHello*/ <'g', ga>
            >
          >
        >
      >

    ClientDTLSPlaintext = 
      <
        /*epoch*/ '0', 
        /*sequence_number*/ '0', 
        /*length*/ rec_recordLength,
        ClientDTLSHandshake
      >

    traffic_key = ga^~b

    serverhello = 
      <
        /*ProtocolVersion*/ protocolVersion(), 
        /*Random32*/ ~random, 
        /*CipherSuite*/ $CipherSuits, 
        /*Extension*/ <
          /*ExtensionType*/ '51', 
          /*KeyshareServerHello*/ <'g', 'g'^~b>
        >
      >

    DTLSHandshakeSH = 
      <
        /*length*/ '200', 
        /*message_seq*/ '0', 
        /*fragment_offset*/ '0', 
        /*fragment_length*/ '200', 
        serverhello
      >

    DTLSPlaintextSH = 
      <
        /*epoch*/ '0', 
        /*sequence_number*/ '0', 
        /*length*/ '210', 
        DTLSHandshakeSH
      >


    finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

    server_finished = 
      <
        /*verify_data*/  hmac(<finished_key, 
                              h1(<ClientDTLSHandshake, DTLSHandshakeSH>)>)
      >
    DTLSHandshakeSF = 
      <
        /*length*/ '400', 
        /*message_seq*/ '1', 
        /*fragment_offset*/ '0', 
        /*fragment_length*/ '400', 
        server_finished
      >
    DTLSInnerPlaintextSF = 
      senc{<
            /*content*/ DTLSHandshakeSF, 
            /*zeros*/ <'0'>, 
            /*ContentType*/ '22'
          >}traffic_key

    DTLSCipherTextSF = 
      <
        /*unified_hdr*/ handshakeCryptoHeader(), 
        /*encrypted_record*/ DTLSInnerPlaintextSF
      >



    
in
    [ In(<ClientDTLSPlaintext, $C, $C>) /*clienthello plaintext*/,
      Fr(~b),
      Fr(~random),
      Fr(~session_id) ]
  --[ Neq('g', ga),
      Start($S, $C, 'server', ~session_id), /* We must make it a note that we are communicating with the client, so we can discard packages out of order*/ 
      Send($S, $C, 'SF', ~session_id),
      DHChan($C, 'client', ~session_id, 'g', ~b, ga, 'g'^~b, traffic_key),
      DH(~session_id, $S, ~b) ]->
    [ Out(<DTLSPlaintextSH, $S, $C>) /*serverhello plaintext*/,
      Out(<DTLSCipherTextSF, $S, $C>) /*server finished*/,
      Keys(<$S, $C, 'g'^~b, ga, ga^~b>),
      ServerFinished(<$S, $C, server_finished, ~session_id>),
      DHExp(~b, ~session_id, $S) ]
    

//ClientFinished
rule ClientFinished:
    let
        traffic_key = gb^a

        

        /* INCOMMING MESSAGE */
        ServerDTLSPlaintext = <
                                /*epoch*/ '0', 
                                /*sequence_number*/ '0', 
                                /*length*/ rec_SHRecordLength, 
                                <
                                  /*length*/ rec_SHMessageLength, 
                                  /*message_seq*/ '0', 
                                  /*fragment_offset*/ rec_SHfragmentOffset, 
                                  /*fragment_length*/ rec_SHfragmentLength, 
                                  <
                                    /*ProtocolVersion*/ protocolVersion(), 
                                    /*Random32*/ rec_serverRandom, 
                                    /*CipherSuite*/ $CipherSuits, 
                                    /*Extension*/ <
                                      /*ExtensionType*/ '51', 
                                      /*KeyshareServerHello*/ <'g', gb>
                                    >
                                  >
                                >
                              >

        DTLSHandshakeSH = <
                            /*length*/ rec_SHMessageLength, 
                            /*message_seq*/ '0', 
                            /*fragment_offset*/ rec_SHFragmentOffset, 
                            /*fragment_length*/ rec_SHFragmentLength, 
                            <
                              /*ProtocolVersion*/ protocolVersion(), 
                              /*Random32*/ random, 
                              /*CipherSuite*/ $CipherSuits, 
                              /*Extension*/ <
                                  /*ExtensionType*/ '51', 
                                  /*KeyshareServerHello*/ <'g', gb>
                              >
                            >
                          >
    
        DTLSPlaintextSH = <
                            /*epoch*/ '0', 
                            /*sequence_number*/ '0', 
                            /*length*/ '210', 
                            DTLSHandshakeSH
                          >                                              

        ServerDTLSCipherTextSF = <
                                  /*unified_hdr*/ handshakeCryptoHeader(), 
                                  /*encrypted_record*/ senc{<
                                    /*content*/ <
                                      /*length*/ rec_SFMessageLength, 
                                      /*message_seq*/ '1', 
                                      /*fragment_offset*/ rec_SFFragmentOffset, 
                                      /*fragment_length*/ rec_SFFragmentLength, 
                                      <
                                        /*verify_data*/ serverFinish
                                      >
                                    >, 
                                    /*zeros*/ <'0'>, 
                                    /*ContentType*/ '22'
                                  >}traffic_key
                                >

        finished_key =  HKDFExpand(<traffic_key, 'finished', 'Hash_length'>)

        client_finished = <
                            /*verify_data*/  hmac(<finished_key, 
                                                  h1(<DTLSHandshake_CH, DTLSHandshakeSH>)>)
                          >

        DTLSInnerPlaintext = <
                                /*content*/ <
                                  /*length*/ '300', 
                                  /*message_seq*/ '0', 
                                  /*fragment_offset*/ '0', 
                                  /*fragment_length*/ '300', 
                                  client_finished
                                >, 
                                /*zeros*/ <'0'>, 
                                /*ContentType*/ '22'
                            >
        DTLSCipherText =  <
                            /*unified_hdr*/ handshakeCryptoHeader(), 
                            /*encrypted_record*/ senc{DTLSInnerPlaintext}traffic_key
                          >

    in
        [ St_ClientHello($C, $S, random, a, session_id),
          In(<DTLSPlaintextSH, $S, $C>) /*serverhello plaintext*/,
          In(<ServerDTLSCipherTextSF, $S, $C>), /*server finished*/
          ClientSessionHandshakeHistory(<$C, $S, <DTLSHandshake_CH>>) ]
      --[ HandshakeComplete($C, $S, session_id, traffic_key),
          Neq('g', gb),
          Eq(client_finished, serverFinish),
          Send($C, $S, 'CF', session_id),
          DHChan($S, 'server', session_id, 'g', a, 'g'^a, gb, traffic_key) ]->
        [ Out(<DTLSCipherText, $C, $S>) /*client finished*/]

rule Ack:
  let
    DTLSCipherText = <
                      /*unified_hdr*/ handshakeCryptoHeader(), 
                      /*encrypted_record*/ senc{<
                        /*content*/ <
                          /*length*/ rec_CFMessageLength, 
                          /*message_seq*/ '0', 
                          /*fragment_offset*/ rec_CFragmentOffset, 
                          /*fragment_length*/ rec_CFragmentLength,
                          client_finished
                        >, 
                        /*zeros*/ <'0'>, 
                        /*ContentType*/ '22'
                      >}traffic_key
                    >
  in
    [ In(<DTLSCipherText, $C, $S>),
      Keys(<$S, $C, gb, ga, traffic_key>),
      ServerFinished(<$S, $C, server_finished, session_id>) ]
  --[ Eq(client_finished, server_finished),
      HandshakeComplete($S, $C, session_id, traffic_key),
      Send($S, $C, 'ACK', session_id) ]->
    []

    
restriction Equal:
"
  All x y #i.
    Eq(x, y) @ #i ==> x = y
"

restriction Not_equal:
"
  All x y #i.
    Neq(x, y) @ #i ==> not(x = y)
"

restriction One_dh_per_x:
  "All tid tid2 x actor actor2 #i #j. 
    DH(tid, actor, x)@i & DH(tid2, actor2, x)@j ==> #i = #j"

restriction Cant_guess_DH_value:
  "
    All C S client_session_id server_session_id g x y gx gy gxy #i #j #r.
      DHChan(C, 'client', client_session_id, g, x, gx, gy, gxy) @ i & 
      DHChan(S, 'server', server_session_id, g, y, gx, gy, gxy) @ j &
      K(gxy) @ r
        ==> (Ex #p. RevDHExp(x, client_session_id, C) @ p & p < r) |
            (Ex #q. RevDHExp(y, server_session_id, S) @ q & q < r)
  "

restriction DEBUG_Only_one_session_client:
"
  All a1 a2 a3 a4 sid1 sid2 #i #j. 
    Start(a1, a2, 'client', sid1) @ i & Start(a3, a4, 'client', sid2) @ j ==> #i = #j
"

restriction DEBUG_Only_one_session_server:
"
  All a1 a2 a3 a4 sid1 sid2 #i #j. 
    Start(a1, a2, 'server', sid1) @ i & Start(a3, a4, 'server', sid2) @ j ==> #i = #j
"

/* If two session has been started, then the first session must have been complete before the new one start   */
restriction R1_Only_one_session_per_pair_at_a_time:
"
  All actor1 actor2 role session_id1 session_id2 #i #j.
    Start(actor1, actor2, role, session_id1) @ i & Start(actor1, actor2, role, session_id2) @ j & i < j
      ==> Ex traffic_key #k. HandshakeComplete(actor1, actor2, session_id1, traffic_key) @ k & k < j & i < k
"

/* Actors may not start a session with them self */
restriction R2_Dont_essablish_session_with_self:
"
  All actor1 actor2 role session_id #i.
    Start(actor1, actor2, role, session_id) @ #i & actor1 = actor2 ==> F
"

/* If a message type is send twich on the same session id, then it must happen at the same time (it has in fact only been send once) */
restriction R3_Dont_resend_messages:
"
  All actor1 actor2 msg_type session_id #i #j.
    Send(actor1, actor2, msg_type, session_id) @ #i & Send(actor1, actor2, msg_type, session_id) @ #j ==> #i = #j
"

// Reachability lemma
lemma L1_reachability_with_both_actors:
  exists-trace
  "Ex C S client_session_id server_session_id traffic_key #i #j #k #l. 
    Start(C, S, 'client', client_session_id) @ i & Start(S, C, 'server', server_session_id) @ j
    & HandshakeComplete(C, S, client_session_id, traffic_key) @ k & HandshakeComplete(S, C, server_session_id, traffic_key) @ l & k < l
    & not(Ex #p. Corrupt(C) @ p & p < l) 
    & not(Ex #q. Corrupt(S) @ q & q < l)
    & not(Ex #r. K(traffic_key) @ r & r < l)
  "

end