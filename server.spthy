// insert relevant imports

// HelloRetryRequest
rule HelloRetryRequest:
    let
        hello_retry_request = {/*ProtocolVersion*/ {254, 253}, /*Random32*/ {random}, /*legacy_session_id*/ [], /*CipherSuite*/ [{CipherSuite_name, two_byte_id}], /*legacy_compression_method*/ 0, /*Extension*/ {/*ExtensionType*/ 51, /*KeyshareHelloRetryRequest*/ {name_of_method, [key_exchange, ...]}, {/*ExtensionType*/ 44, /*Cookie*/ {cookie_that_depend_on_client_address}}}}
        DTLSHandshake = {/*length*/ random, /*message_seq*/ 0, /*fragment_offset*/ 0, /*fragment_length*/ length, hello_retry_request}
        DTLSPlaintext = {/*epoch*/ 0, /*sequence_number*/ 1, /*length*/ DTLSHandshake length+x, DTLSHandshake}
    in
    [in(DTLSPlaintext, $C) /*clienthello plaintext*/]
    --[  ]->
    [Out(DTLSPlaintext, $S) /*helloretryrequest plaintext*/]


// ServerHello
rule ServerHello:
    let
        serverhello = {/*ProtocolVersion*/ {254, 253}, /*Random32*/ {random}, /*legacy_session_id_echo*/ [], /*CipherSuite*/ [{CipherSuite_name, two_byte_id}], /*legacy_compression_method*/ 0, /*Extension*/ {/*ExtensionType*/ 51, /*KeyshareHelloRetryRequest*/ {name_of_method, [key_exchange, ...]}}}
        DTLSHandshake = {/*length*/ random, /*message_seq*/ 0, /*fragment_offset*/ 0, /*fragment_length*/ length, server_hello}
        DTLSPlaintext = {/*epoch*/ 0, /*sequence_number*/ 3, /*length*/ DTLSHandshake length+x, DTLSHandshake}
    in
    [in(DTLSPlaintext, $C) /*clienthellocookie plaintext*/]
    --[  ]->
    [Out(DTLSPlaintext, $S) /*serverhello plaintext*/,
     St_server_sends_hello($S, $C, 'Server sent hello to client. Send encrypted extensions')]


// EncryptedExtensions
rule EncryptedExtensions:
    let
        encrypted_extensions = {/*Extension*/ {/*ExtensionType*/ 51, /*KeyshareEncryptedExtensions*/ {name_of_method, [key_exchange, ...]}}}
        DTLSHandshake = {/*length*/ random, /*message_seq*/ 0, /*fragment_offset*/ 0, /*fragment_length*/ length, encrypted_extensions}
        DTLSInnerPlaintext = {/*content*/ DTLSHandshake, /*zeros*/ [0], /*ContentType*/ 22}
        DTLSCipherText = {/*unified_hdr*/ {/*first three bits*/ 001, /*C*/ Connection_id, /*S*/ 4, /*E*/ 2 /*2 fordi lige encrypted right?*/}, /*encrypted_record*/ DTLSInnerPlaintext}
        
    in
    [St_server_sends_hello($S, $C, 'Server sent hello to client. Send encrypted extensions')]
    --[  ]->
    [Out(DTLSCipherText, $S) /*encrypted extensions*/,
     St_server_sends_encrypted_extensions($S, $C, 'Server sent encrypted extensions to client. Send certificate request')]


// ServerCertificate
rule ServerCertificate:
    let
        server_certificate = {/*certificate_request_context*/ [], /*certificate_entry*/ {/*certificate_type*/ 'server certificate', /*Extension*/ {/*ExtensionType*/ 13, /*KeyshareCertificateRequest*/ {name_of_method, [key_exchange, ...]}}}}
        DTLSHandshake = {/*length*/ random, /*message_seq*/ 0, /*fragment_offset*/ 0, /*fragment_length*/ length, server_certificate}
        DTLSInnerPlaintext = {/*content*/ DTLSHandshake, /*zeros*/ [0], /*ContentType*/ 22}
        DTLSCipherText = {/*unified_hdr*/ {/*first three bits*/ 001, /*C*/ Connection_id, /*S*/ 5, /*E*/ 2 /*2 fordi lige encrypted right?*/}, /*encrypted_record*/ DTLSInnerPlaintext}
        
    in
    [St_server_sends_certificate_request($S, $C, 'Server sent certificate request to client. Send server certificate')]
    --[  ]->
    [Out(DTLSCipherText, $S) /*server certificate*/,
     St_server_sends_server_certificate($S, $C, 'Server sent server certificate to client. Send server certificate verify')]


// CertificateVerify
rule CertificateVerify:
    let
        certificate_verify = {/*certificate_request_context*/ [], /*certificate_entry*/ {/*certificate_type*/ 'certificate verify', /*Extension*/ {/*ExtensionType*/ 13, /*KeyshareCertificateRequest*/ {name_of_method, [key_exchange, ...]}}}}
        DTLSHandshake = {/*length*/ random, /*message_seq*/ 0, /*fragment_offset*/ 0, /*fragment_length*/ length, certificate_verify}
        DTLSInnerPlaintext = {/*content*/ DTLSHandshake, /*zeros*/ [0], /*ContentType*/ 22}
        DTLSCipherText = {/*unified_hdr*/ {/*first three bits*/ 001, /*C*/ Connection_id, /*S*/ 6, /*E*/ 2 /*2 fordi lige encrypted right?*/}, /*encrypted_record*/ DTLSInnerPlaintext}
        
    in
    [St_server_sends_server_certificate($S, $C, 'Server sent server certificate to client. Send server certificate verify')]
    --[  ]->
    [Out(DTLSCipherText, $S) /*certificate verify*/,
     St_server_sends_certificate_verify($S, $C, 'Server sent certificate verify to client. Send server finished')]


// ServerFinished
rule ServerFinished:
    let
        server_finished = {/*verify_data*/ HMAC(HKDF-Expand-Label(Transcript-Hash(Handshake Context, ServerCertificate), "finished", "", 12), Transcript-Hash(Handshake Context, CertificateVerify))}
        DTLSHandshake = {/*length*/ random, /*message_seq*/ 0, /*fragment_offset*/ 0, /*fragment_length*/ length, server_finished}
        DTLSInnerPlaintext = {/*content*/ DTLSHandshake, /*zeros*/ [0], /*ContentType*/ 22}
        DTLSCipherText = {/*unified_hdr*/ {/*first three bits*/ 001, /*C*/ Connection_id, /*S*/ 7, /*E*/ 2 /*2 fordi lige encrypted right?*/}, /*encrypted_record*/ DTLSInnerPlaintext}
        
    in
    [St_server_sends_certificate_verify($S, $C, 'Server sent certificate verify to client. Send server finished')]
    --[  ]->
    [Out(DTLSCipherText, $S) /*server finished*/,
]


// Ack
rule Ack:
    let
    ACK = {/*record_numbers */ [0,1,2,3,4,5,6,7]}
    DTLSInnerPlaintext = {/*content*/ ACK, /*zeros*/ [0], /*ContentType*/ 26}
    DTLSCipherText = {/*unified_hdr*/ {/*first three bits*/ 001, /*C*/ Connection_id, /*S*/ 8, /*E*/ 3}, /*encrypted_record*/ DTLSInnerPlaintext}
    in
    [in(DTLSCipherText, $C) /*client finished*/]
    --[  ]->
    [Out(DTLSPlaintext, $S) /*ack*/]